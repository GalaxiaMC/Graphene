From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: notsatvrn <satvrn@disroot.org>
Date: Thu, 18 Aug 2022 23:29:23 +0000
Subject: [PATCH] API Classes

diff --git a/src/main/java/com/destroystokyo/paper/event/player/PlayerLoadDataEvent.java b/src/main/java/com/destroystokyo/paper/event/player/PlayerLoadDataEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..550252772998d11dbc4269568c86bfaf43157cf6
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/event/player/PlayerLoadDataEvent.java
@@ -0,0 +1,64 @@
+package com.destroystokyo.paper.event.player;
+
+import com.google.gson.JsonObject;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.UUID;
+
+/**
+ * Calls an event in which playerdata can be provided. If null, will load from disk, otherwise will use provided data
+ */
+public class PlayerLoadDataEvent extends Event {
+    private static final HandlerList handlers = new HandlerList();
+    private final UUID playerId;
+    private Object playerData;
+    private JsonObject statistics;
+
+    public PlayerLoadDataEvent(@NotNull UUID playerId) {
+        super();
+        this.playerId = playerId;
+    }
+
+    /**
+     * Gets the player's unique ID.
+     *
+     * @return The unique ID
+     */
+    @NotNull
+    public UUID getUniqueId() {
+        return playerId;
+    }
+
+    @Nullable
+    public Object getPlayerData() {
+        return playerData;
+    }
+
+    public void setPlayerData(@NotNull Object playerData) {
+        this.playerData = playerData;
+    }
+
+    @Nullable
+    public JsonObject getStatistics() {
+        return statistics;
+    }
+
+    public void setStatistics(@NotNull JsonObject statistics) {
+        this.statistics = statistics;
+    }
+
+    @NotNull
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
+
diff --git a/src/main/java/com/destroystokyo/paper/event/player/PlayerSaveDataEvent.java b/src/main/java/com/destroystokyo/paper/event/player/PlayerSaveDataEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..c79000af79c49949d939e0aae75e90f28fbd6809
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/event/player/PlayerSaveDataEvent.java
@@ -0,0 +1,53 @@
+package com.destroystokyo.paper.event.player;
+
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Calls whenever playerdata is attempted to be saved. This is fired even if SpigotConfig.disablePlayerDataSaving is true
+ */
+public class PlayerSaveDataEvent extends Event implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+    private final Player player;
+    private boolean cancel;
+
+    public PlayerSaveDataEvent(@NotNull Player player) {
+        super();
+        this.player = player;
+    }
+
+    /**
+     * Gets the player
+     *
+     * @return The player
+     */
+    @NotNull
+    public Player getPlayer() {
+        return player;
+    }
+
+    @NotNull
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return cancel;
+    }
+
+    @Override
+    public void setCancelled(boolean cancel) {
+        this.cancel = cancel;
+    }
+}
+
diff --git a/src/main/java/dev/mrfishcakes/crunchy/CrunchyUtil.java b/src/main/java/dev/mrfishcakes/crunchy/CrunchyUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..023ff96d083370e64386606f1cd8faa0c86c4986
--- /dev/null
+++ b/src/main/java/dev/mrfishcakes/crunchy/CrunchyUtil.java
@@ -0,0 +1,30 @@
+package dev.mrfishcakes.crunchy;
+
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import org.bukkit.ChatColor;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Map;
+
+/**
+ * Class for managing simple/repetitive methods used within Crunchy
+ *
+ * @author MrFishCakes
+ */
+public final class CrunchyUtil {
+
+    private CrunchyUtil() {
+        throw new UnsupportedOperationException("CrunchyUtil cannot be initiated");
+    }
+
+    public static void sendMessage(@NotNull CommandSender sender, @NotNull String message) {
+        sender.sendMessage(ChatColor.translateAlternateColorCodes('&', message.replaceAll("''", "'")));
+    }
+
+    public static void sendMessage(@NotNull MiniMessage miniMessage, @NotNull CommandSender sender, @NotNull String message) {
+        sender.sendMessage(miniMessage.deserialize(message.replaceAll("''", "'")));
+    }
+
+}
+
diff --git a/src/main/java/dev/mrfishcakes/crunchy/SkullBuilder.java b/src/main/java/dev/mrfishcakes/crunchy/SkullBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..85227fd9e0ada7bf589f87f9740bf61b1dffbedf
--- /dev/null
+++ b/src/main/java/dev/mrfishcakes/crunchy/SkullBuilder.java
@@ -0,0 +1,157 @@
+package dev.mrfishcakes.crunchy;
+
+import com.destroystokyo.paper.profile.PlayerProfile;
+import com.destroystokyo.paper.profile.ProfileProperty;
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.SkullMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.UUID;
+import java.util.function.Consumer;
+import java.util.logging.Level;
+
+/**
+ * Class for creating skulls easily and applying {@link SkullMeta}
+ *
+ * @author MrFishCales
+ */
+public class SkullBuilder {
+
+    /**
+     * Enum for managing skull types
+     */
+    public enum SkullType {
+
+        CREEPER(Material.CREEPER_HEAD),
+        DRAGON(Material.DRAGON_HEAD),
+        PLAYER(Material.PLAYER_HEAD),
+        SKELETON(Material.SKELETON_SKULL),
+        WITHER_SKELETON(Material.WITHER_SKELETON_SKULL),
+        ZOMBIE(Material.ZOMBIE_HEAD);
+
+        private final Material material;
+
+        SkullType(@NotNull Material material) {
+            this.material = material;
+        }
+
+        /**
+         * Returns the material that is used to make the skull
+         *
+         * @return {@link Material} type for the skull
+         */
+        public Material getMaterial() {
+            return material;
+        }
+
+    }
+
+    private final SkullType skullType;
+    private final ItemStack itemStack;
+    private final SkullMeta skullMeta;
+
+    /**
+     * Create a new instance of the class
+     *
+     * @param skullType {@link SkullType} that should be used when creating the {@link ItemStack}
+     */
+    public SkullBuilder(@NotNull SkullType skullType) {
+        this.skullType = skullType;
+        this.itemStack = new ItemStack(skullType.getMaterial());
+        this.skullMeta = (SkullMeta) itemStack.getItemMeta();
+    }
+
+    /**
+     * Create a default new instance of the class
+     * <p>
+     * This will create a {@link SkullType#PLAYER} by default
+     *
+     * @see Material#PLAYER_HEAD
+     */
+    public SkullBuilder() {
+        this(SkullType.PLAYER);
+    }
+
+    /**
+     * Set the {@link OfflinePlayer} owner of the skull
+     *
+     * @param player {@link OfflinePlayer} to set the value as
+     * @return Updated instance
+     */
+    public SkullBuilder setOfflinePlayer(@NotNull OfflinePlayer player) {
+        if (skullType != SkullType.PLAYER) {
+            Bukkit.getLogger().log(Level.SEVERE, "Cannot assign player value to non-player skull", new IllegalArgumentException(
+                    "Cannot assign player value to a non-player skull"));
+            return this;
+        }
+
+        skullMeta.setOwningPlayer(player);
+
+        return this;
+    }
+
+    /**
+     * Set a custom texture to the skull.
+     * <p>
+     * This allows for more customisation where heads are needed
+     *
+     * @param value     Skin value
+     * @param signature Skin signature
+     * @return Updated instance
+     */
+    public SkullBuilder setCustomTexture(@NotNull String value, @Nullable String signature) {
+        if (skullType != SkullType.PLAYER) {
+            Bukkit.getLogger().log(Level.SEVERE, "Cannot assign player skin value to non-player skull", new IllegalArgumentException(
+                    "Cannot assign player skin value to a non-player skull"));
+            return this;
+        }
+
+        PlayerProfile profile = Bukkit.createProfile(UUID.randomUUID());
+        profile.setProperty(new ProfileProperty("textures", value, signature));
+
+        skullMeta.setPlayerProfile(profile);
+
+        return this;
+    }
+
+    /**
+     * Set a custom texture to the skull.
+     * <p>
+     * This allows for more customisation where heads are needed
+     *
+     * @param value Skin value
+     * @return Updated instance
+     * @see SkullBuilder#setCustomTexture(String, String)
+     */
+    public SkullBuilder setCustomTexture(@NotNull String value) {
+        return setCustomTexture(value, null);
+    }
+
+    /**
+     * Apply custom {@link SkullMeta} to the item
+     *
+     * @param consumer {@link SkullMeta} to apply
+     * @return Updated instance
+     */
+    public SkullBuilder applyItemMeta(@NotNull Consumer<SkullMeta> consumer) {
+        consumer.accept(skullMeta);
+
+        return this;
+    }
+
+    /**
+     * Get the final {@link ItemStack} for the skull
+     *
+     * @return Skull as item
+     */
+    public ItemStack build() {
+        itemStack.setItemMeta(skullMeta);
+        return itemStack;
+    }
+
+}
+
diff --git a/src/main/java/io/papermc/paper/event/block/BlockDestroyedByNeighborEvent.java b/src/main/java/io/papermc/paper/event/block/BlockDestroyedByNeighborEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..555195d87b08e933fbe4ecaaf7446ab7cf49bf9b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/event/block/BlockDestroyedByNeighborEvent.java
@@ -0,0 +1,68 @@
+package io.papermc.paper.event.block;
+
+import org.bukkit.block.Block;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.block.BlockEvent;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Called when a block is broken another block. This is generally the result of BlockPhysicsEvent propagation
+ */
+public class BlockDestroyedByNeighborEvent extends BlockEvent implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+    private final Player player;
+    private final Block sourceBlock;
+    private boolean cancel;
+
+    public BlockDestroyedByNeighborEvent(@NotNull final Block theBlock, @Nullable Player player, @NotNull final Block sourceBlock) {
+        super(theBlock);
+
+        this.player = player;
+        this.sourceBlock = sourceBlock;
+    }
+
+    /**
+     * Gets the Player that caused this
+     *
+     * @return The Player that is breaking the block involved in this event
+     */
+    @Nullable
+    public Player getPlayer() {
+        return player;
+    }
+
+    /**
+     * Gets the source block that caused this block break
+     *
+     * @return The Source Block which block is involved in this event
+     */
+    @NotNull
+    public final Block getSourceBlock() {
+        return sourceBlock;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return cancel;
+    }
+
+    @Override
+    public void setCancelled(boolean cancel) {
+        this.cancel = cancel;
+    }
+
+    @Override
+    @NotNull
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
+
diff --git a/src/main/java/io/papermc/paper/event/player/PlayerShieldDisableEvent.java b/src/main/java/io/papermc/paper/event/player/PlayerShieldDisableEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..532ece7792199a6e2e425e36d43429b905034aa5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/event/player/PlayerShieldDisableEvent.java
@@ -0,0 +1,51 @@
+package io.papermc.paper.event.player;
+
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.player.PlayerEvent;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Thrown whenever a Player's shield is disabled
+ */
+public class PlayerShieldDisableEvent extends PlayerEvent implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+    private final Entity damager;
+    private boolean cancelled = false;
+
+    public PlayerShieldDisableEvent(@NotNull final Player player, @Nullable final Entity damager) {
+        super(player);
+        this.damager = damager;
+    }
+
+    @Nullable
+    public Entity getDamager() {
+        return damager;
+    }
+
+    @NotNull
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    @Override
+    public void setCancelled(boolean cancel) {
+        cancelled = cancel;
+    }
+}
+
diff --git a/src/main/java/org/bukkit/event/player/PlayerGetRespawnLocationEvent.java b/src/main/java/org/bukkit/event/player/PlayerGetRespawnLocationEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..3cc140f397350f0f775e052dc204cb208ddb6f9c
--- /dev/null
+++ b/src/main/java/org/bukkit/event/player/PlayerGetRespawnLocationEvent.java
@@ -0,0 +1,54 @@
+package org.bukkit.event.player;
+
+import org.apache.commons.lang.Validate;
+import org.bukkit.Location;
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Called when a respawn event tries to determine the location of a respawn
+ */
+public class PlayerGetRespawnLocationEvent extends PlayerEvent {
+    private static final HandlerList handlers = new HandlerList();
+    private Location respawnLocation;
+
+    public PlayerGetRespawnLocationEvent(@NotNull final Player respawnPlayer) {
+        super(respawnPlayer);
+    }
+
+    /**
+     * Gets the current respawn location
+     *
+     * @return Location current respawn location
+     */
+    @Nullable
+    public Location getRespawnLocation() {
+        return this.respawnLocation;
+    }
+
+    /**
+     * Sets the new respawn location
+     *
+     * @param respawnLocation new location for the respawn
+     */
+    public void setRespawnLocation(@NotNull Location respawnLocation) {
+        Validate.notNull(respawnLocation, "Respawn location can not be null");
+        Validate.notNull(respawnLocation.getWorld(), "Respawn world can not be null");
+
+        this.respawnLocation = respawnLocation;
+    }
+
+    @NotNull
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
+
diff --git a/src/main/java/org/bukkit/event/player/PlayerTrackEntityEvent.java b/src/main/java/org/bukkit/event/player/PlayerTrackEntityEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..80521af2e044edb9406a28d93c742537515915d5
--- /dev/null
+++ b/src/main/java/org/bukkit/event/player/PlayerTrackEntityEvent.java
@@ -0,0 +1,41 @@
+package org.bukkit.event.player;
+
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Called when a player tracks an entity.
+ */
+public class PlayerTrackEntityEvent extends PlayerEvent {
+    private static final HandlerList handlers = new HandlerList();
+    private final Entity tracked;
+
+    public PlayerTrackEntityEvent(@NotNull final Player player, @NotNull final Entity tracked) {
+        super(player);
+        this.tracked = tracked;
+    }
+
+    /**
+     * Gets the entity newly tracked by the Player
+     *
+     * @return Entity the player is now tracking
+     */
+    @NotNull
+    public Entity getTracked() {
+        return tracked;
+    }
+
+    @NotNull
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
+
diff --git a/src/main/java/org/yatopiamc/yatopia/api/internal/StackTraceUtils.java b/src/main/java/org/yatopiamc/yatopia/api/internal/StackTraceUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..6a19b0639f449e8aab0ffcb28602df7a79130a98
--- /dev/null
+++ b/src/main/java/org/yatopiamc/yatopia/api/internal/StackTraceUtils.java
@@ -0,0 +1,106 @@
+package org.yatopiamc.yatopia.api.internal;
+
+import com.google.common.base.Suppliers;
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginLoader;
+import org.bukkit.plugin.SimplePluginManager;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.bukkit.plugin.java.JavaPluginLoader;
+import org.bukkit.plugin.java.PluginClassLoader;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+
+public class StackTraceUtils {
+
+    public static final String EXCEPTION_DETAILS_BELOW = "Exception details below: ";
+
+    private static final Supplier<Map<Plugin, Set<Class<?>>>> loadedClassesSupplier = Suppliers.memoizeWithExpiration(StackTraceUtils::scanForPluginClasses, 5, TimeUnit.SECONDS);
+
+    public static void print(StackTraceElement[] stackTrace, Consumer<String> out) {
+        Set<Plugin> suspectedPlugins = getSuspectedPluginsFromStackTrace(stackTrace);
+
+        printSuspectedPlugins(out, suspectedPlugins);
+    }
+
+    public static void print(Throwable t, Consumer<String> out) {
+        Set<Plugin> suspectedPlugins = getSuspectedPluginsFromStackTrace(getStackTracesFromThrowable(t).toArray(new StackTraceElement[0]));
+
+        printSuspectedPlugins(out, suspectedPlugins);
+    }
+
+    private static Set<StackTraceElement> getStackTracesFromThrowable(Throwable t) {
+        if(t == null) return Collections.emptySet();
+        Set<StackTraceElement> elements = new ObjectOpenHashSet<>();
+        elements.addAll(getStackTracesFromThrowable(t.getCause()));
+        elements.addAll(Arrays.stream(t.getSuppressed()).flatMap(throwable -> getStackTracesFromThrowable(throwable).stream()).collect(Collectors.toSet()));
+        elements.addAll(Arrays.asList(t.getStackTrace()));
+        return elements;
+    }
+
+    private static void printSuspectedPlugins(Consumer<String> out, Set<Plugin> suspectedPlugins) {
+        if (!suspectedPlugins.isEmpty()) {
+            out.accept("Suspected Plugins: ");
+            for (Plugin plugin : suspectedPlugins) {
+                StringBuilder builder = new StringBuilder("\t");
+                builder.append(plugin.getName())
+                        .append("{")
+                        .append(plugin.isEnabled() ? "enabled" : "disabled")
+                        .append(",").append("ver=").append(plugin.getDescription().getVersion());
+                if (!plugin.isNaggable())
+                    builder.append(",").append("nag");
+                if (plugin instanceof JavaPlugin)
+                    builder.append(",").append("path=").append(((JavaPlugin) plugin).getFile());
+
+                builder.append("}");
+                out.accept(builder.toString());
+            }
+        } else {
+            out.accept("Suspected Plugins: None");
+        }
+    }
+
+    private static Set<Plugin> getSuspectedPluginsFromStackTrace(StackTraceElement[] stackTrace) {
+        Map<Plugin, Set<Class<?>>> loadedClasses = loadedClassesSupplier.get();
+        Set<Plugin> suspectedPlugins = new HashSet<>();
+        for (StackTraceElement stackTraceElement : stackTrace) {
+            for (Map.Entry<Plugin, Set<Class<?>>> pluginSetEntry : loadedClasses.entrySet()) {
+                if (pluginSetEntry.getValue().stream().anyMatch(clazz -> clazz.getName().equals(stackTraceElement.getClassName())))
+                    suspectedPlugins.add(pluginSetEntry.getKey());
+            }
+        }
+        return suspectedPlugins;
+    }
+
+    private static Map<Plugin, Set<Class<?>>> scanForPluginClasses() {
+        Map<Plugin, Set<Class<?>>> loadedClasses = new Object2ObjectOpenHashMap<>();
+        if (Bukkit.getPluginManager() instanceof SimplePluginManager) {
+            final SimplePluginManager pluginManager = (SimplePluginManager) Bukkit.getPluginManager();
+            final Collection<PluginLoader> pluginLoaders = pluginManager.getPluginLoaders();
+            for (PluginLoader pluginLoader : pluginLoaders) {
+                if (pluginLoader instanceof JavaPluginLoader) {
+                    JavaPluginLoader javaPluginLoader = (JavaPluginLoader) pluginLoader;
+                    final List<PluginClassLoader> classLoaders = javaPluginLoader.getClassLoaders();
+                    for (PluginClassLoader classLoader : classLoaders) {
+                        loadedClasses.put(classLoader.getPlugin(), new ObjectOpenHashSet<>(classLoader.getLoadedClasses()));
+                    }
+                }
+            }
+        }
+        return loadedClasses;
+    }
+
+}
+
