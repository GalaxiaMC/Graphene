From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon Gardling <titaniumtown@gmail.com>
Date: Thu, 8 Jul 2021 17:03:31 -0400
Subject: [PATCH] Use MCUtil.asyncExecutor for MAIN_WORKER_EXECUTOR in Util

Instead of creating a new threadpool for `MAIN_WORKER_EXECUTOR` in `Util`, this patch makes it so `MAIN_WORKER_EXECUTOR` just passes the `execute()` method over to `MCUtil.asyncExecutor` for it to be executed on that threadpool instead.

diff --git a/src/main/java/net/minecraft/Util.java b/src/main/java/net/minecraft/Util.java
index f09ac28a49863c02491d38342ecd6237c0511d5c..e65a2f74c2d9ff850ace0bd822c273286a1f3095 100644
--- a/src/main/java/net/minecraft/Util.java
+++ b/src/main/java/net/minecraft/Util.java
@@ -61,6 +61,10 @@ import net.minecraft.util.datafix.DataFixers;
 import net.minecraft.world.level.block.state.properties.Property;
 import org.apache.commons.io.IOUtils;
 import org.slf4j.Logger;
+import java.util.concurrent.AbstractExecutorService;
+import me.titaniumtown.util.ServerWorkerWrapper;
+import net.minecraft.server.MCUtil;
+import java.util.Collections;

 public class Util {
     static final Logger LOGGER = LogUtils.getLogger();
@@ -148,7 +152,43 @@ public class Util {
         if (i <= 0) {
             executorService = MoreExecutors.newDirectExecutorService();
         } else {
-            executorService = new java.util.concurrent.ThreadPoolExecutor(i, i,0L, TimeUnit.MILLISECONDS, new java.util.concurrent.LinkedBlockingQueue<Runnable>(), target -> new net.minecraft.server.ServerWorkerThread(target, s, priorityModifier));
+            executorService = Integer.getInteger("Paper.WorkerThreadCount", i) <= 0 ? MoreExecutors.newDirectExecutorService() : new AbstractExecutorService(){
+                    private volatile boolean shutdown = false;
+
+                    @Override
+                    public final List<Runnable> shutdownNow() {
+                        this.shutdown = true;
+                        return Collections.emptyList();
+                    }
+
+                    @Override
+                    public final void shutdown() {
+                        this.shutdown = true;
+                    }
+
+                    @Override
+                    public final boolean isShutdown() {
+                        return this.shutdown;
+                    }
+
+                    @Override
+                    public final boolean isTerminated() {
+                        return this.shutdown;
+                    }
+
+                    @Override
+                    public final boolean awaitTermination(long l2, TimeUnit timeUnit) throws InterruptedException {
+                        if (!this.shutdown) {
+                            throw new UnsupportedOperationException();
+                        }
+                        return true;
+                    }
+
+                    @Override
+                    public final void execute(Runnable runnable) {
+                        MCUtil.asyncExecutor.execute(new ServerWorkerWrapper(runnable));
+                    }
+            };
         }
         /*
                     @Override

