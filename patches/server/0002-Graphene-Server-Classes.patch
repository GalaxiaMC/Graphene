From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: satvrn <pastawho@gmail.com>
Date: Wed, 27 Sep 2023 02:07:40 -0700
Subject: [PATCH] Graphene: Server Classes


diff --git a/src/main/java/me/jellysquid/mods/lithium/util/Constants.java b/src/main/java/me/jellysquid/mods/lithium/util/Constants.java
new file mode 100644
index 0000000000000000000000000000000000000000..776292a6910a027d10ed53745b429c773e4f3f74
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/util/Constants.java
@@ -0,0 +1,20 @@
+package me.jellysquid.mods.lithium.util;
+
+/**
+ * Credits to the CaffeineMC team for the original code (from Lithium): https://github.com/CaffeineMC/lithium-fabric
+ * A number of new constants have been added.
+ */
+
+/**
+ * Pre-initialized constants to avoid unnecessary allocations.
+ */
+public final class Constants {
+    public static final byte[] BYTE_EMPTY = new byte[0];
+
+    public static final int[] INT_EMPTY = new int[0];
+    public static final int[] INT_ZERO = new int[]{0};
+    public static final int[] INT_ONE = new int[]{1};
+    public static final int[] INT_TWO = new int[]{2};
+
+    public static final long[] LONG_EMPTY = new long[0];
+}
diff --git a/src/main/java/me/jellysquid/mods/lithium/util/math/CompactSineLUT.java b/src/main/java/me/jellysquid/mods/lithium/util/math/CompactSineLUT.java
new file mode 100644
index 0000000000000000000000000000000000000000..d7ade60e3b20326edb50c4c1452176e47d8f2722
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/util/math/CompactSineLUT.java
@@ -0,0 +1,94 @@
+package me.jellysquid.mods.lithium.util.math;
+
+/**
+ * Credits to the CaffeineMC team for the original code (from Lithium): https://github.com/CaffeineMC/lithium-fabric
+ * No significant changes have been made.
+ */
+
+import net.minecraft.util.Mth;
+
+/**
+ * A replacement for the sine angle lookup table used in {@link Mth}, both reducing the size of LUT and improving
+ * the access patterns for common paired sin/cos operations.
+ *
+ *  sin(-x) = -sin(x)
+ *    ... to eliminate negative angles from the LUT.
+ *
+ *  sin(x) = sin(pi/2 - x)
+ *    ... to eliminate supplementary angles from the LUT.
+ *
+ * Using these identities allows us to reduce the LUT from 64K entries (256 KB) to just 16K entries (64 KB), enabling
+ * it to better fit into the CPU's caches at the expense of some cycles on the fast path. The implementation has been
+ * tightly optimized to avoid branching where possible and to use very quick integer operations.
+ *
+ * Generally speaking, reducing the size of a lookup table is always a good optimization, but since we need to spend
+ * extra CPU cycles trying to maintain parity with vanilla, there is the potential risk that this implementation ends
+ * up being slower than vanilla when the lookup table is able to be kept in cache memory.
+ *
+ * Unlike other "fast math" implementations, the values returned by this class are *bit-for-bit identical* with those
+ * from {@link Mth}. Validation is performed during runtime to ensure that the table is correct.
+ *
+ * @author coderbot16   Author of the original (and very clever) implementation in Rust:
+ *  https://gitlab.com/coderbot16/i73/-/tree/master/i73-trig/src
+ * @author jellysquid3  Additional optimizations, port to Java
+ */
+public class CompactSineLUT {
+    private static final int[] SIN_INT = new int[16384 + 1];
+    private static final float SIN_MIDPOINT;
+
+    static {
+        // Copy the sine table, covering to raw int bits
+        for (int i = 0; i < SIN_INT.length; i++) {
+            SIN_INT[i] = Float.floatToRawIntBits(Mth.SIN[i]);
+        }
+
+        SIN_MIDPOINT = Mth.SIN[Mth.SIN.length / 2];
+
+        // Test that the lookup table is correct during runtime
+        for (int i = 0; i < Mth.SIN.length; i++) {
+            float expected = Mth.SIN[i];
+            float value = lookup(i);
+
+            if (expected != value) {
+                throw new IllegalArgumentException(String.format("LUT error at index %d (expected: %s, found: %s)", i, expected, value));
+            }
+        }
+    }
+
+    // [VanillaCopy] Mth#sin(float)
+    public static float sin(float f) {
+        return lookup((int) (f * 10430.378f) & 0xFFFF);
+    }
+
+    // [VanillaCopy] Mth#cos(float)
+    public static float cos(float f) {
+        return lookup((int) (f * 10430.378f + 16384.0f) & 0xFFFF);
+    }
+
+    private static float lookup(int index) {
+        // A special case... Is there some way to eliminate this?
+        if (index == 32768) {
+            return SIN_MIDPOINT;
+        }
+
+        // Trigonometric identity: sin(-x) = -sin(x)
+        // Given a domain of 0 <= x <= 2*pi, just negate the value if x > pi.
+        // This allows the sin table size to be halved.
+        int neg = (index & 0x8000) << 16;
+
+        // All bits set if (pi/2 <= x), none set otherwise
+        // Extracts the 15th bit from 'half'
+        int mask = (index << 17) >> 31;
+
+        // Trigonometric identity: sin(x) = sin(pi/2 - x)
+        int pos = (0x8001 & mask) + (index ^ mask);
+
+        // Wrap the position in the table. Moving this down to immediately before the array access
+        // seems to help the Hotspot compiler optimize the bit math better.
+        pos &= 0x7fff;
+
+        // Fetch the corresponding value from the LUT and invert the sign bit as needed
+        // This directly manipulate the sign bit on the float bits to simplify logic
+        return Float.intBitsToFloat(SIN_INT[pos] ^ neg);
+    }
+}
diff --git a/src/main/java/me/satvrn/random/XorwowRandom.java b/src/main/java/me/satvrn/random/XorwowRandom.java
new file mode 100644
index 0000000000000000000000000000000000000000..e4362c922aec04b594d880a60c636b310a79a145
--- /dev/null
+++ b/src/main/java/me/satvrn/random/XorwowRandom.java
@@ -0,0 +1,64 @@
+package me.satvrn.random;
+
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.Random;
+
+public class XorwowRandom extends Random {
+    static class RandomHelper {
+        static final long multiplier = 0x5DEECE66DL;
+        static final long mask = (1L << 48) - 1;
+        static long seedUniquifier() {
+            for (;;) {
+                long current = seedUniquifier.get();
+                long next = current * 1181783497276652981L;
+                if (seedUniquifier.compareAndSet(current, next)) {
+                    return next;
+                }
+            }
+        }
+        static final AtomicLong seedUniquifier = new AtomicLong(8682522807148012L);
+        static long initialScramble(long seed) {
+            return (seed ^ multiplier) & mask;
+        }
+    
+        static long createSeed() {
+            return initialScramble(seedUniquifier() ^ System.nanoTime());
+        }
+    }
+
+    public long x = RandomHelper.createSeed();
+    public long y = 362436069L;
+    public long z = 521288629L;
+    public long w = 88675123L;
+    public long v = 5783321L;
+    public long d = 6615241L;
+
+    public XorwowRandom() {
+        super();
+    }
+
+    public XorwowRandom(long seed) {
+        super(seed);
+    }
+
+    @Override
+    public long nextLong() {
+        long t = (x ^ (x >> 2));
+        x = y;
+        y = z;
+        z = w;
+        w = v;
+        v = (v ^ (v << 4)) ^ (t ^ (t << 1));
+        return (d += 362437) + v;
+    }
+
+    @Override
+    public void setSeed(long seed) {
+        x = seed;
+        y = 362436069L;
+        z = 521288629L;
+        w = 88675123L;
+        v = 5783321L;
+        d = 6615241L;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/steinborn/krypton/mod/shared/network/util/VarIntUtil.java b/src/main/java/me/steinborn/krypton/mod/shared/network/util/VarIntUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..937fd6d3b162c34aa9109223e1771d2ab79d83cb
--- /dev/null
+++ b/src/main/java/me/steinborn/krypton/mod/shared/network/util/VarIntUtil.java
@@ -0,0 +1,25 @@
+package me.steinborn.krypton.mod.shared.network.util;
+
+/**
+ * Credits to the Andrew Steinborn for the original code (from Krypton): https://github.com/astei/krypton
+ * No changes have been made.
+ */
+
+/**
+ * Maps VarInt byte sizes to a lookup table corresponding to the number of bits in the integer,
+ * from zero to 32.
+ */
+public class VarIntUtil {
+    private static final int[] VARINT_EXACT_BYTE_LENGTHS = new int[33];
+
+    static {
+        for (int i = 0; i <= 32; ++i) {
+            VARINT_EXACT_BYTE_LENGTHS[i] = (int) Math.ceil((31d - (i - 1)) / 7d);
+        }
+        VARINT_EXACT_BYTE_LENGTHS[32] = 1; // Special case for 0.
+    }
+
+    public static int getVarIntLength(int value) {
+        return VARINT_EXACT_BYTE_LENGTHS[Integer.numberOfLeadingZeros(value)];
+    }
+}
