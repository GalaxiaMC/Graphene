From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: notsatvrn <satvrn@disroot.org>
Date: Thu, 18 Aug 2022 23:29:23 +0000
Subject: [PATCH] Server Classes

diff --git a/src/main/java/com/ishland/c2me/common/optimization/reduce_allocs/ObjectCachingUtils.java b/src/main/java/com/ishland/c2me/common/optimization/reduce_allocs/ObjectCachingUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..af60994acc4ee7ae287d91ff0539491d2fd124e8
--- /dev/null
+++ b/src/main/java/com/ishland/c2me/common/optimization/reduce_allocs/ObjectCachingUtils.java
@@ -0,0 +1,24 @@
+package com.ishland.c2me.common.optimization.reduce_allocs;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+
+import java.util.BitSet;
+import java.util.function.IntFunction;
+
+public class ObjectCachingUtils {
+
+    private static final IntFunction<BitSet> bitSetConstructor = BitSet::new;
+
+    public static ThreadLocal<Int2ObjectOpenHashMap<BitSet>> BITSETS = ThreadLocal.withInitial(Int2ObjectOpenHashMap::new);
+
+    private ObjectCachingUtils() {
+    }
+
+    public static BitSet getCachedOrNewBitSet(int bits) {
+        final BitSet bitSet = BITSETS.get().computeIfAbsent(bits, bitSetConstructor);
+        bitSet.clear();
+        return bitSet;
+    }
+
+}
+
diff --git a/src/main/java/com/ishland/c2me/opts/worldgen/general/common/random_instances/RandomUtils.java b/src/main/java/com/ishland/c2me/opts/worldgen/general/common/random_instances/RandomUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..831583be273381fab3fcc8e782478ce3f2b8b7ba
--- /dev/null
+++ b/src/main/java/com/ishland/c2me/opts/worldgen/general/common/random_instances/RandomUtils.java
@@ -0,0 +1,52 @@
+package com.ishland.c2me.opts.worldgen.general.common.random_instances;
+
+import net.minecraft.util.Mth;
+import net.minecraft.world.level.levelgen.LegacyRandomSource;
+import net.minecraft.world.level.levelgen.PositionalRandomFactory;
+import net.minecraft.world.level.levelgen.RandomSource;
+import net.minecraft.world.level.levelgen.SingleThreadedRandomSource;
+import net.minecraft.world.level.levelgen.Xoroshiro128PlusPlus;
+import net.minecraft.world.level.levelgen.XoroshiroRandomSource;
+
+public class RandomUtils {
+
+    private static final ThreadLocal<XoroshiroRandomSource> xoroshiro = ThreadLocal.withInitial(() -> new XoroshiroRandomSource(0L, 0L));
+    private static final ThreadLocal<SingleThreadedRandomSource> simple = ThreadLocal.withInitial(() -> new SingleThreadedRandomSource(0L));
+
+    public static void derive(PositionalRandomFactory deriver, RandomSource random, int x, int y, int z) {
+        if (deriver instanceof XoroshiroRandomSource.XoroshiroPositionalRandomFactory deriver1) {
+            final Xoroshiro128PlusPlus implementation = ((XoroshiroRandomSource) random).getRandomNumberGenerator();
+            implementation.setSeedLo(Mth.getSeed(x, y, z) ^ deriver1.getSeedLo());
+            implementation.setSeedHi(deriver1.getSeedHi());
+            return;
+        }
+        if (deriver instanceof LegacyRandomSource.LegacyPositionalRandomFactory deriver1) {
+            final SingleThreadedRandomSource random1 = (SingleThreadedRandomSource) random;
+            random1.setSeed(Mth.getSeed(x, y, z) ^ deriver1.getSeed());
+            return;
+        }
+        throw new IllegalArgumentException();
+    }
+
+    public static RandomSource getThreadLocalRandom(PositionalRandomFactory deriver) {
+        if (deriver instanceof XoroshiroRandomSource.XoroshiroPositionalRandomFactory) {
+            return xoroshiro.get();
+        }
+        if (deriver instanceof LegacyRandomSource.LegacyPositionalRandomFactory) {
+            return simple.get();
+        }
+        throw new IllegalArgumentException();
+    }
+
+    public static RandomSource getRandom(PositionalRandomFactory deriver) {
+        if (deriver instanceof XoroshiroRandomSource.XoroshiroPositionalRandomFactory) {
+            return new XoroshiroRandomSource(0L, 0L);
+        }
+        if (deriver instanceof LegacyRandomSource.LegacyPositionalRandomFactory) {
+            return new SingleThreadedRandomSource(0L);
+        }
+        throw new IllegalArgumentException();
+    }
+
+}
+
diff --git a/src/main/java/com/notsatvrn/graphene/GrapheneConfig.java b/src/main/java/com/notsatvrn/graphene/GrapheneConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..4da04db87961f269918d40fdcddd8b4ae79183a4
--- /dev/null
+++ b/src/main/java/com/notsatvrn/graphene/GrapheneConfig.java
@@ -0,0 +1,149 @@
+package tk.galaxiamc.graphene;
+
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableMap;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+import tk.galaxiamc.graphene.command.GrapheneCommand;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+
+@SuppressWarnings("unused")
+public class GrapheneConfig {
+    private static final String HEADER = "This is the main configuration file for Graphene.\n"
+            + "As you can see, there's tons to configure. Some options may impact gameplay, so use\n"
+            + "with caution, and make sure you know what each option does before configuring.\n";
+    private static File CONFIG_FILE;
+    public static YamlConfiguration config;
+
+    private static Map<String, Command> commands;
+
+    public static int version;
+    static boolean verbose;
+
+    public static void init(File configFile) {
+        CONFIG_FILE = configFile;
+        config = new YamlConfiguration();
+        try {
+            config.load(CONFIG_FILE);
+        } catch (IOException ignore) {
+        } catch (InvalidConfigurationException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not load graphene.yml, please correct your syntax errors", ex);
+            throw Throwables.propagate(ex);
+        }
+        config.options().header(HEADER);
+        config.options().copyDefaults(true);
+        verbose = getBoolean("verbose", false);
+
+        commands = new HashMap<>();
+        commands.put("graphene", new GrapheneCommand("graphene"));
+
+        version = getInt("config-version", 1);
+        set("config-version", 1);
+
+        readConfig(GrapheneConfig.class, null);
+    }
+
+    protected static void log(String s) {
+        if (verbose) {
+            log(Level.INFO, s);
+        }
+    }
+
+    protected static void log(Level level, String s) {
+        Bukkit.getLogger().log(level, s);
+    }
+
+    public static void registerCommands() {
+        for (Map.Entry<String, Command> entry : commands.entrySet()) {
+            MinecraftServer.getServer().server.getCommandMap().register(entry.getKey(), "Graphene", entry.getValue());
+        }
+    }
+
+    static void readConfig(Class<?> clazz, Object instance) {
+        for (Method method : clazz.getDeclaredMethods()) {
+            if (Modifier.isPrivate(method.getModifiers())) {
+                if (method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE) {
+                    try {
+                        method.setAccessible(true);
+                        method.invoke(instance);
+                    } catch (InvocationTargetException ex) {
+                        throw Throwables.propagate(ex.getCause());
+                    } catch (Exception ex) {
+                        Bukkit.getLogger().log(Level.SEVERE, "Error invoking " + method, ex);
+                    }
+                }
+            }
+        }
+
+        try {
+            config.save(CONFIG_FILE);
+        } catch (IOException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not save " + CONFIG_FILE, ex);
+        }
+    }
+
+    private static void set(String path, Object val) {
+        config.addDefault(path, val);
+        config.set(path, val);
+    }
+
+    private static String getString(String path, String def) {
+        config.addDefault(path, def);
+        return config.getString(path, config.getString(path));
+    }
+
+    private static boolean getBoolean(String path, boolean def) {
+        config.addDefault(path, def);
+        return config.getBoolean(path, config.getBoolean(path));
+    }
+
+    private static double getDouble(String path, double def) {
+        config.addDefault(path, def);
+        return config.getDouble(path, config.getDouble(path));
+    }
+
+    private static int getInt(String path, int def) {
+        config.addDefault(path, def);
+        return config.getInt(path, config.getInt(path));
+    }
+
+    private static <T> List getList(String path, T def) {
+        config.addDefault(path, def);
+        return config.getList(path, config.getList(path));
+    }
+
+    static Map<String, Object> getMap(String path, Map<String, Object> def) {
+        if (def != null && config.getConfigurationSection(path) == null) {
+            config.addDefault(path, def);
+            return def;
+        }
+        return toMap(config.getConfigurationSection(path));
+    }
+
+    private static Map<String, Object> toMap(ConfigurationSection section) {
+        ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();
+        if (section != null) {
+            for (String key : section.getKeys(false)) {
+                Object obj = section.get(key);
+                if (obj != null) {
+                    builder.put(key, obj instanceof ConfigurationSection val ? toMap(val) : obj);
+                }
+            }
+        }
+        return builder.build();
+    }
+}
+
diff --git a/src/main/java/com/notsatvrn/graphene/GrapheneWorldConfig.java b/src/main/java/com/notsatvrn/graphene/GrapheneWorldConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..59f383dde35970e82d7ea7137ba5e12d2c0c402d
--- /dev/null
+++ b/src/main/java/com/notsatvrn/graphene/GrapheneWorldConfig.java
@@ -0,0 +1,79 @@
+package tk.galaxiamc.graphene;
+
+import net.minecraft.server.level.ServerLevel;
+import org.apache.commons.lang.BooleanUtils;
+import org.bukkit.configuration.ConfigurationSection;
+
+import java.util.List;
+import java.util.Map;
+import java.util.function.Predicate;
+
+import static tk.galaxiamc.graphene.GrapheneConfig.log;
+
+@SuppressWarnings("unused")
+public class GrapheneWorldConfig {
+
+    private final String worldName;
+
+    public GrapheneWorldConfig(String worldName) {
+        this.worldName = worldName;
+        init();
+    }
+
+    public void init() {
+        log("-------- World Settings For [" + worldName + "] --------");
+        GrapheneConfig.readConfig(GrapheneWorldConfig.class, this);
+    }
+
+    private void set(String path, Object val) {
+        GrapheneConfig.config.addDefault("world-settings.default." + path, val);
+        GrapheneConfig.config.set("world-settings.default." + path, val);
+        if (GrapheneConfig.config.get("world-settings." + worldName + "." + path) != null) {
+            GrapheneConfig.config.addDefault("world-settings." + worldName + "." + path, val);
+            GrapheneConfig.config.set("world-settings." + worldName + "." + path, val);
+        }
+    }
+
+    private ConfigurationSection getConfigurationSection(String path) {
+        ConfigurationSection section = GrapheneConfig.config.getConfigurationSection("world-settings." + worldName + "." + path);
+        return section != null ? section : GrapheneConfig.config.getConfigurationSection("world-settings.default." + path);
+    }
+
+    private String getString(String path, String def) {
+        GrapheneConfig.config.addDefault("world-settings.default." + path, def);
+        return GrapheneConfig.config.getString("world-settings." + worldName + "." + path, GrapheneConfig.config.getString("world-settings.default." + path));
+    }
+
+    private boolean getBoolean(String path, boolean def) {
+        GrapheneConfig.config.addDefault("world-settings.default." + path, def);
+        return GrapheneConfig.config.getBoolean("world-settings." + worldName + "." + path, GrapheneConfig.config.getBoolean("world-settings.default." + path));
+    }
+
+    private boolean getBoolean(String path, Predicate<Boolean> predicate) {
+        String val = getString(path, "default").toLowerCase();
+        Boolean bool = BooleanUtils.toBooleanObject(val, "true", "false", "default");
+        return predicate.test(bool);
+    }
+
+    private double getDouble(String path, double def) {
+        GrapheneConfig.config.addDefault("world-settings.default." + path, def);
+        return GrapheneConfig.config.getDouble("world-settings." + worldName + "." + path, GrapheneConfig.config.getDouble("world-settings.default." + path));
+    }
+
+    private int getInt(String path, int def) {
+        GrapheneConfig.config.addDefault("world-settings.default." + path, def);
+        return GrapheneConfig.config.getInt("world-settings." + worldName + "." + path, GrapheneConfig.config.getInt("world-settings.default." + path));
+    }
+
+    private <T> List<?> getList(String path, T def) {
+        GrapheneConfig.config.addDefault("world-settings.default." + path, def);
+        return GrapheneConfig.config.getList("world-settings." + worldName + "." + path, GrapheneConfig.config.getList("world-settings.default." + path));
+    }
+
+    private Map<String, Object> getMap(String path, Map<String, Object> def) {
+        final Map<String, Object> fallback = GrapheneConfig.getMap("world-settings.default." + path, def);
+        final Map<String, Object> value = GrapheneConfig.getMap("world-settings." + worldName + "." + path, null);
+        return value.isEmpty() ? fallback : value;
+    }
+}
+
diff --git a/src/main/java/com/notsatvrn/graphene/command/GrapheneCommand.java b/src/main/java/com/notsatvrn/graphene/command/GrapheneCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..0854558ab89d9ba4ef6b9682b4f328e2bd3d6052
--- /dev/null
+++ b/src/main/java/com/notsatvrn/graphene/command/GrapheneCommand.java
@@ -0,0 +1,67 @@
+package tk.galaxiamc.graphene.command;
+
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import tk.galaxiamc.graphene.GrapheneConfig;
+
+import java.io.File;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class GrapheneCommand extends Command {
+    public GrapheneCommand(String name) {
+        super(name);
+        this.description = "Graphene related commands";
+        this.usageMessage = "/graphene [reload | version]";
+        this.setPermission("bukkit.command.graphene");
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+        if (args.length == 1) {
+            return Stream.of("reload", "version")
+                    .filter(arg -> arg.startsWith(args[0].toLowerCase()))
+                    .collect(Collectors.toList());
+        }
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (args.length != 1) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        if (args[0].equalsIgnoreCase("reload")) {
+            Command.broadcastCommandMessage(sender, ChatColor.RED + "Please note that this command is not supported and may cause issues.");
+            Command.broadcastCommandMessage(sender, ChatColor.RED + "If you encounter any issues please use the /stop command to restart your server.");
+
+            MinecraftServer console = MinecraftServer.getServer();
+            GrapheneConfig.init((File) console.options.valueOf("graphene-settings"));
+            for (ServerLevel level : console.getAllLevels()) {
+                level.grapheneConfig.init();
+                level.resetBreedingCooldowns();
+            }
+            console.server.reloadCount++;
+
+            Command.broadcastCommandMessage(sender, ChatColor.GREEN + "Graphene config reload complete.");
+        } else if (args[0].equalsIgnoreCase("version")) {
+            Command verCmd = org.bukkit.Bukkit.getServer().getCommandMap().getCommand("version");
+            if (verCmd != null) {
+                return verCmd.execute(sender, commandLabel, me.titaniumtown.Constants.EMPTY_string_arr);
+            }
+        }
+
+        return true;
+    }
+}
+
diff --git a/src/main/java/de/nycode/nyper/NyperConfig.java b/src/main/java/de/nycode/nyper/NyperConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..612d43b7cb2208a8a1c2fd660d06b383f700978f
--- /dev/null
+++ b/src/main/java/de/nycode/nyper/NyperConfig.java
@@ -0,0 +1,193 @@
+package de.nycode.nyper;
+
+import com.destroystokyo.paper.PaperCommand;
+import com.google.common.base.Throwables;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+import java.util.regex.Pattern;
+
+public class NyperConfig {
+
+    private static File CONFIG_FILE;
+    private static final String HEADER = "This is the main configuration file for options provided by Nyper.";
+
+    /*========================================================================*/
+    public static YamlConfiguration config;
+    static int version;
+    static Map<String, Command> commands;
+    private static boolean verbose;
+    private static boolean fatalError;
+    /*========================================================================*/
+    private static boolean metricsStarted;
+
+    public static void init(File configFile) {
+        CONFIG_FILE = configFile;
+        config = new YamlConfiguration();
+        try {
+            config.load(CONFIG_FILE);
+        } catch (IOException ignored) {
+        } catch (InvalidConfigurationException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not load nyper.yml, please correct your syntax errors", ex);
+            throw Throwables.propagate(ex);
+        }
+        config.options().header(HEADER);
+        config.options().copyDefaults(true);
+        verbose = getBoolean("verbose", false);
+
+        commands = new HashMap<>();
+        commands.put("nyper", new PaperCommand("nyper"));
+
+        version = getInt("config-version", 1);
+        set("config-version", 1);
+        readConfig(NyperConfig.class, null);
+    }
+
+    protected static void logError(String s) {
+        Bukkit.getLogger().severe(s);
+    }
+
+    protected static void fatal(String s) {
+        fatalError = true;
+        throw new RuntimeException("Fatal nyper.yml config error: " + s);
+    }
+
+    protected static void log(String s) {
+        if (verbose) {
+            Bukkit.getLogger().info(s);
+        }
+    }
+
+    public static void registerCommands() {
+        for (Map.Entry<String, Command> entry : commands.entrySet()) {
+            MinecraftServer.getServer().server.getCommandMap().register(entry.getKey(), "Paper", entry.getValue());
+        }
+    }
+
+    static void readConfig(Class<?> clazz, Object instance) {
+        for (Method method : clazz.getDeclaredMethods()) {
+            if (Modifier.isPrivate(method.getModifiers())) {
+                if (method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE) {
+                    try {
+                        method.setAccessible(true);
+                        method.invoke(instance);
+                    } catch (InvocationTargetException ex) {
+                        throw Throwables.propagate(ex.getCause());
+                    } catch (Exception ex) {
+                        Bukkit.getLogger().log(Level.SEVERE, "Error invoking " + method, ex);
+                    }
+                }
+            }
+        }
+
+        try {
+            config.save(CONFIG_FILE);
+        } catch (IOException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not save " + CONFIG_FILE, ex);
+        }
+    }
+
+    private static final Pattern SPACE = Pattern.compile(" ");
+    private static final Pattern NOT_NUMERIC = Pattern.compile("[^-\\d.]");
+
+    public static int getSeconds(String str) {
+        str = SPACE.matcher(str).replaceAll("");
+        final char unit = str.charAt(str.length() - 1);
+        str = NOT_NUMERIC.matcher(str).replaceAll("");
+        double num;
+        try {
+            num = Double.parseDouble(str);
+        } catch (Exception e) {
+            num = 0D;
+        }
+        switch (unit) {
+            case 'd':
+                num *= (double) 60 * 60 * 24;
+                break;
+            case 'h':
+                num *= (double) 60 * 60;
+                break;
+            case 'm':
+                num *= (double) 60;
+                break;
+            default:
+            case 's':
+                break;
+        }
+        return (int) num;
+    }
+
+    protected static String timeSummary(int seconds) {
+        String time = "";
+
+        if (seconds > 60 * 60 * 24) {
+            time += TimeUnit.SECONDS.toDays(seconds) + "d";
+            seconds %= 60 * 60 * 24;
+        }
+
+        if (seconds > 60 * 60) {
+            time += TimeUnit.SECONDS.toHours(seconds) + "h";
+            seconds %= 60 * 60;
+        }
+
+        if (seconds > 0) {
+            time += TimeUnit.SECONDS.toMinutes(seconds) + "m";
+        }
+        return time;
+    }
+
+    private static void set(String path, Object val) {
+        config.set(path, val);
+    }
+
+    private static boolean getBoolean(String path, boolean def) {
+        config.addDefault(path, def);
+        return config.getBoolean(path, config.getBoolean(path));
+    }
+
+    private static double getDouble(String path, double def) {
+        config.addDefault(path, def);
+        return config.getDouble(path, config.getDouble(path));
+    }
+
+    private static float getFloat(String path, float def) {
+        // TODO: Figure out why getFloat() always returns the default value.
+        return (float) getDouble(path, (double) def);
+    }
+
+    private static int getInt(String path, int def) {
+        config.addDefault(path, def);
+        return config.getInt(path, config.getInt(path));
+    }
+
+    private static <T> List getList(String path, T def) {
+        config.addDefault(path, def);
+        return (List<T>) config.getList(path, config.getList(path));
+    }
+
+    private static String getString(String path, String def) {
+        config.addDefault(path, def);
+        return config.getString(path, config.getString(path));
+    }
+
+    public static boolean hidePlayerIps = false;
+
+    private static void hidePlayerIps() {
+        hidePlayerIps = getBoolean("settings.hide-player-ips", hidePlayerIps);
+    }
+
+}
+
diff --git a/src/main/java/dev/mrfishcakes/crunchy/commands/CrunchyCommand.java b/src/main/java/dev/mrfishcakes/crunchy/commands/CrunchyCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..7386e98bf0568a8f768aa3032460a4db1f7b8172
--- /dev/null
+++ b/src/main/java/dev/mrfishcakes/crunchy/commands/CrunchyCommand.java
@@ -0,0 +1,88 @@
+package dev.mrfishcakes.crunchy.commands;
+
+import dev.mrfishcakes.crunchy.CrunchyUtil;
+import dev.mrfishcakes.crunchy.config.CrunchyConfig;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * Class to manage the basic <i>/crunchy</i> command
+ *
+ * @author MrFishCakes
+ */
+public class CrunchyCommand extends Command {
+
+    public CrunchyCommand() {
+        super("crunchy");
+        this.description = "Crunchy related commands";
+        this.usageMessage = "/crunchy [reload | version]";
+        this.setPermission("bukkit.command.crunchy");
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, @NotNull String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (args.length != 1) {
+            CrunchyUtil.sendMessage(sender, ChatColor.RED + "Usage: " + usageMessage);
+            return true;
+        }
+
+        switch (args[0].toLowerCase()) {
+            case "reload":
+            case "rl":
+                reloadCrunchy(sender);
+                break;
+            case "ver":
+            case "version":
+                Command versionCommand = MinecraftServer.getServer().server.getCommandMap().getCommand("version");
+                if (versionCommand != null) {
+                    versionCommand.execute(sender, commandLabel, me.titaniumtown.Constants.EMPTY_string_arr);
+                    break;
+                }
+            default:
+                CrunchyUtil.sendMessage(sender, ChatColor.RED + "Usage: " + usageMessage);
+                return false;
+        }
+
+        return true;
+    }
+
+    @Override
+    @NotNull
+    public List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args) throws IllegalArgumentException {
+        if (args.length == 1) {
+            return Stream.of("reload", "version").filter(arg -> arg.startsWith(args[0].toLowerCase())).collect(Collectors.toList());
+        }
+
+        return Collections.emptyList();
+    }
+
+    private void reloadCrunchy(CommandSender sender) {
+        Command.broadcastCommandMessage(sender, ChatColor.RED + "Please not this command is not supported and may cause issues.");
+        Command.broadcastCommandMessage(sender, ChatColor.RED + "If you encounter any issues please use the /stop command to restart your server.");
+
+        MinecraftServer console = MinecraftServer.getServer();
+
+        CrunchyConfig.init((File) console.options.valueOf("crunchy-settings"));
+        for (ServerLevel level : console.getAllLevels()) {
+            level.crunchyConfig.init();
+        }
+
+        console.server.reloadCount++;
+
+        Command.broadcastCommandMessage(sender, ChatColor.GREEN + "Crunchy config reload complete.");
+    }
+
+}
+
diff --git a/src/main/java/dev/mrfishcakes/crunchy/commands/StopCommand.java b/src/main/java/dev/mrfishcakes/crunchy/commands/StopCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..781742c21ceab00e981aa69df6973f531bcb958e
--- /dev/null
+++ b/src/main/java/dev/mrfishcakes/crunchy/commands/StopCommand.java
@@ -0,0 +1,133 @@
+package dev.mrfishcakes.crunchy.commands;
+
+import dev.mrfishcakes.crunchy.CrunchyUtil;
+import dev.mrfishcakes.crunchy.config.CrunchyConfig;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import javax.swing.Timer;
+import java.util.*;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * Class to manage the <i>/stop</i> command
+ *
+ * @author MrFishCakes
+ */
+public class StopCommand extends Command {
+
+    private static final Map<String, TimeUnit> VALID_UNITS = new HashMap<>() {{
+        put("sec", TimeUnit.SECONDS);
+        put("secs", TimeUnit.SECONDS);
+        put("seconds", TimeUnit.SECONDS);
+        put("min", TimeUnit.MINUTES);
+        put("mins", TimeUnit.MINUTES);
+        put("minutes", TimeUnit.MINUTES);
+        put("hr", TimeUnit.HOURS);
+        put("hrs", TimeUnit.HOURS);
+        put("hours", TimeUnit.HOURS);
+    }};
+
+    private static Timer stopTimer;
+
+    private final MiniMessage message;
+
+    public StopCommand() {
+        super("stop");
+        this.description = "Enhanced stop command";
+        this.usageMessage = "/stop [time | cancel] [unit]";
+        this.setPermission("bukkit.command.stop");
+        this.message = MiniMessage.miniMessage();
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, @NotNull String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (args.length == 1 || args.length == 2) {
+            if (args[0].equalsIgnoreCase("cancel")) {
+                if (stopTimer == null) {
+                    CrunchyUtil.sendMessage(message, sender, CrunchyConfig.stopCommandNotScheduled);
+                    return true;
+                }
+
+                try {
+                    stopTimer.stop();
+                } catch (Exception ex) { // Just in case
+                    CrunchyUtil.sendMessage(message, sender, CrunchyConfig.stopCommandCancelFail);
+                    return true;
+                }
+
+                CrunchyUtil.sendMessage(message, sender, CrunchyConfig.stopCommandCancelled);
+                stopTimer = null;
+                return true;
+            }
+
+            if (stopTimer != null) {
+                CrunchyUtil.sendMessage(message, sender, CrunchyConfig.stopCommandAlreadyScheduled);
+                return true;
+            }
+
+            int time;
+            TimeUnit unit = TimeUnit.SECONDS;
+
+            try {
+                time = Integer.parseInt(args[0]);
+            } catch (NumberFormatException ex) {
+                return sendUsageMessage(sender);
+            }
+
+            if (time < 1) return sendUsageMessage(sender);
+
+            if (args.length == 2) {
+                unit = VALID_UNITS.get(args[1].toLowerCase());
+
+                if (unit == null) unit = TimeUnit.SECONDS;
+            }
+
+            stopTimer = new Timer((int) unit.toMillis(time), e -> Bukkit.shutdown());
+
+            stopTimer.setRepeats(false);
+            stopTimer.start();
+
+            CrunchyUtil.sendMessage(message, sender, CrunchyConfig.stopCommandSuccess);
+            return true;
+        } else if (args.length == 0) {
+            Bukkit.shutdown();
+            return true;
+        } else {
+            return sendUsageMessage(sender);
+        }
+    }
+
+    @Override
+    @NotNull
+    public List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args) throws IllegalArgumentException {
+        if (!testPermissionSilent(sender)) return Collections.emptyList();
+
+        if (args.length == 1) {
+            if (stopTimer == null) return Collections.singletonList("[time]");
+
+            return Stream.of("cancel").filter(arg -> arg.startsWith(args[0].toLowerCase())).collect(Collectors.toList());
+        }
+
+        if (args.length == 2) {
+            return VALID_UNITS.keySet().stream().filter(arg -> arg.startsWith(args[0].toLowerCase())).collect(Collectors.toList());
+        }
+
+        return Collections.emptyList();
+    }
+
+    private boolean sendUsageMessage(CommandSender sender) {
+        CrunchyUtil.sendMessage(sender, ChatColor.RED + "Usage: " + usageMessage);
+        return true;
+    }
+
+}
+
diff --git a/src/main/java/dev/mrfishcakes/crunchy/config/CrunchyConfig.java b/src/main/java/dev/mrfishcakes/crunchy/config/CrunchyConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..8571cf4619453bdacb1ba3a5010e344228a8eb17
--- /dev/null
+++ b/src/main/java/dev/mrfishcakes/crunchy/config/CrunchyConfig.java
@@ -0,0 +1,163 @@
+package dev.mrfishcakes.crunchy.config;
+
+import dev.mrfishcakes.crunchy.commands.CrunchyCommand;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+
+/**
+ * Class to manage all global options relating to Crunchy
+ *
+ * @author MrFishCakes
+ */
+public final class CrunchyConfig {
+
+    private static final String HEADER = """
+            Configuration file for Crunchy.
+                        
+            More options will be added to this file over time, but to ensure that each
+            setting is correctly configured, refer to the wiki page before changing anything.
+                        
+            This can be found at: https://github.com/MrFishCakes/Crunchy
+                        
+            Thank you for using Crunchy! :)
+            """;
+    private static File configFile;
+    private static Map<String, Command> commands;
+
+    public static YamlConfiguration config;
+
+    static int version = 2;
+    static boolean verbose = false; // Debug logging
+
+    public static boolean verbose() {
+        return verbose;
+    }
+
+    public static void init(@NotNull File file) {
+        if (file == null) {
+            throw new IllegalArgumentException("File parameter cannot be null");
+        }
+
+        configFile = file;
+        commands = new HashMap<>();
+
+        commands.put("crunchy", new CrunchyCommand());
+
+        if (!configFile.exists()) {
+            try {
+                configFile.createNewFile();
+            } catch (Exception ex) {
+                log(Level.SEVERE, String.format("Unable to create '%s' file", configFile.getName()), ex);
+            }
+        }
+
+        config = new YamlConfiguration();
+
+        try {
+            config.load(configFile);
+        } catch (InvalidConfigurationException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, String.format("Unable to load '%s' due to syntax errors", configFile.getName()), ex);
+
+            throw new RuntimeException(ex);
+        } catch (Exception ex) {
+            Bukkit.getLogger().log(Level.SEVERE, String.format("Unable to load '%s'", configFile.getName()), ex);
+
+            throw new RuntimeException(ex);
+        }
+
+        config.options().copyDefaults(true);
+        config.options().header(HEADER);
+
+        verbose = getBoolean("verbose", false);
+        version = getInt("version", 2);
+        set("version", 2);
+
+        readConfig(CrunchyConfig.class, null);
+    }
+
+    public static void registerCommands() {
+        commands.forEach((key, value) -> MinecraftServer.getServer().server.getCommandMap().register(key, "Crunchy", value));
+    }
+
+    static void readConfig(@NotNull Class<?> clazz, @Nullable Object instance) {
+        for (Method method : clazz.getDeclaredMethods()) {
+            if (Modifier.isPrivate(method.getModifiers())) {
+                if (method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE) {
+                    try {
+                        method.setAccessible(true);
+                        method.invoke(instance);
+                    } catch (Exception ex) {
+                        log(Level.SEVERE, String.format("Unable to invoke method ('%s')", method.getName()), ex);
+                    }
+                }
+            }
+        }
+
+        try {
+            config.save(configFile);
+        } catch (Exception ex) {
+            log(Level.SEVERE, String.format("Unable to save '%s'", configFile.getName()), ex);
+        }
+    }
+
+    static void log(@NotNull Level level, @NotNull String message, @Nullable Throwable throwable) {
+        if (throwable != null)
+            Bukkit.getLogger().log(level, message, throwable);
+        else
+            Bukkit.getLogger().log(level, message);
+    }
+
+    static void log(@NotNull Level level, @NotNull String message) {
+        log(level, message, null);
+    }
+
+    private static void set(String path, Object value) {
+        config.addDefault(path, value);
+        config.set(path, value);
+    }
+
+    private static String getString(String path, String def) {
+        config.addDefault(path, def);
+        return config.getString(path, config.getString(path));
+    }
+
+    private static boolean getBoolean(String path, boolean def) {
+        config.addDefault(path, def);
+        return config.getBoolean(path, config.getBoolean(path));
+    }
+
+    private static int getInt(String path, int def) {
+        config.addDefault(path, def);
+        return config.getInt(path, config.getInt(path));
+    }
+
+    private static double getDouble(String path, double def) {
+        config.addDefault(path, def);
+        return config.getDouble(path, config.getDouble(path));
+    }
+
+    private static long getLong(String path, long def) {
+        config.addDefault(path, def);
+        return config.getLong(path, config.getLong(path));
+    }
+
+    private static List<?> getList(String path, List<?> def) {
+        config.addDefault(path, def);
+        return config.getList(path, config.getList(path));
+    }
+
+}
+
diff --git a/src/main/java/dev/mrfishcakes/crunchy/config/CrunchyWorldConfig.java b/src/main/java/dev/mrfishcakes/crunchy/config/CrunchyWorldConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..029996d5f83249d6236b89eb6bdf54416112b4b3
--- /dev/null
+++ b/src/main/java/dev/mrfishcakes/crunchy/config/CrunchyWorldConfig.java
@@ -0,0 +1,85 @@
+package dev.mrfishcakes.crunchy.config;
+
+import org.bukkit.configuration.ConfigurationSection;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+import java.util.logging.Level;
+
+import static dev.mrfishcakes.crunchy.config.CrunchyConfig.config;
+
+/**
+ * Class to manage all per-world options relating to Crunchy
+ *
+ * @author MrFishCakes
+ */
+public final class CrunchyWorldConfig {
+
+    private final String levelName;
+    private final String defaultPath;
+    private final String namedPath;
+
+    public CrunchyWorldConfig(@NotNull String levelName) {
+        this.levelName = levelName;
+        this.defaultPath = "world-settings.default.";
+        this.namedPath = "world-settings." + levelName + ".";
+
+        init();
+    }
+
+    public void init() {
+        if (CrunchyConfig.verbose()) {
+            CrunchyConfig.log(Level.INFO, String.format("-------- World Settings For [%s] --------", levelName));
+        }
+
+        CrunchyConfig.readConfig(CrunchyWorldConfig.class, this);
+    }
+
+    private void set(String path, Object value) {
+        config.addDefault(defaultPath + path, value);
+        config.set(defaultPath + path, value);
+
+        if (config.get(namedPath + path) != null) {
+            config.addDefault(namedPath + path, value);
+            config.set(namedPath + path, value);
+        }
+    }
+
+    private ConfigurationSection getSection(String path) {
+        ConfigurationSection section = config.getConfigurationSection(namedPath + path);
+
+        return section != null ? section : config.getConfigurationSection(defaultPath + path);
+    }
+
+    private String getString(String path, String def) {
+        config.addDefault(defaultPath + path, def);
+        return config.getString(namedPath + path, config.getString(defaultPath + path));
+    }
+
+    private boolean getBoolean(String path, boolean def) {
+        config.addDefault(defaultPath + path, def);
+        return config.getBoolean(namedPath + path, config.getBoolean(defaultPath + path));
+    }
+
+    private int getInt(String path, int def) {
+        config.addDefault(defaultPath + path, def);
+        return config.getInt(namedPath + path, config.getInt(defaultPath + path));
+    }
+
+    private double getDouble(String path, double def) {
+        config.addDefault(defaultPath + path, def);
+        return config.getDouble(namedPath + path, config.getDouble(defaultPath + path));
+    }
+
+    private long getLong(String path, long def) {
+        config.addDefault(defaultPath + path, def);
+        return config.getLong(namedPath + path, config.getLong(defaultPath + path));
+    }
+
+    private List<?> getList(String path, List<?> def) {
+        config.addDefault(defaultPath + path, def);
+        return config.getList(namedPath + path, config.getList(defaultPath + path));
+    }
+
+}
+
diff --git a/src/main/java/dev/mrfishcakes/crunchy/recipe/CrunchyRecipeManager.java b/src/main/java/dev/mrfishcakes/crunchy/recipe/CrunchyRecipeManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..c6760decc1759462ca94e300c4a398bfe6814ba8
--- /dev/null
+++ b/src/main/java/dev/mrfishcakes/crunchy/recipe/CrunchyRecipeManager.java
@@ -0,0 +1,57 @@
+package dev.mrfishcakes.crunchy.recipe;
+
+import dev.mrfishcakes.crunchy.config.CrunchyConfig;
+import dev.mrfishcakes.crunchy.recipe.smeltable.RawCopperBlock;
+import dev.mrfishcakes.crunchy.recipe.smeltable.RawGoldBlock;
+import dev.mrfishcakes.crunchy.recipe.smeltable.RawIronBlock;
+import org.bukkit.Bukkit;
+import org.bukkit.NamespacedKey;
+import org.bukkit.inventory.Recipe;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.logging.Level;
+
+public final class CrunchyRecipeManager {
+
+    private static final AtomicBoolean INITIATED = new AtomicBoolean(false);
+    private static CrunchyRecipeManager instance;
+
+    public static CrunchyRecipeManager instance() {
+        return instance != null ? instance : new CrunchyRecipeManager();
+    }
+
+    private CrunchyRecipeManager() {
+        if (!INITIATED.compareAndSet(false, true)) return;
+
+        instance = this;
+
+        if (CrunchyConfig.smeltRawCopperBlock.enabled()) {
+            registerRecipe(RawCopperBlock.BLASTING, new RawCopperBlock.BlastFurnace());
+            registerRecipe(RawCopperBlock.FURNACE, new RawCopperBlock.Furnace());
+        }
+
+        if (CrunchyConfig.smeltRawGoldBlock.enabled()) {
+            registerRecipe(RawGoldBlock.BLASTING, new RawGoldBlock.BlastFurnace());
+            registerRecipe(RawGoldBlock.FURNACE, new RawGoldBlock.Furnace());
+        }
+
+        if (CrunchyConfig.smeltRawIronBlock.enabled()) {
+            registerRecipe(RawIronBlock.BLASTING, new RawIronBlock.BlastFurnace());
+            registerRecipe(RawIronBlock.FURNACE, new RawIronBlock.Furnace());
+        }
+    }
+
+    public void registerRecipe(@NotNull NamespacedKey key, @NotNull Recipe recipe) {
+        if (!Bukkit.addRecipe(recipe)) {
+            Bukkit.getLogger().log(Level.SEVERE, String.format("Unable to register the recipe '%s'", key.getKey()));
+        }
+    }
+
+}
+
diff --git a/src/main/java/dev/mrfishcakes/crunchy/recipe/smeltable/RawCopperBlock.java b/src/main/java/dev/mrfishcakes/crunchy/recipe/smeltable/RawCopperBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..785fd6be3dd67e865a63c777af2a4a14037b3444
--- /dev/null
+++ b/src/main/java/dev/mrfishcakes/crunchy/recipe/smeltable/RawCopperBlock.java
@@ -0,0 +1,35 @@
+package dev.mrfishcakes.crunchy.recipe.smeltable;
+
+import dev.mrfishcakes.crunchy.config.CrunchyConfig;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.inventory.BlastingRecipe;
+import org.bukkit.inventory.FurnaceRecipe;
+import org.bukkit.inventory.ItemStack;
+
+public class RawCopperBlock {
+
+    public static final NamespacedKey BLASTING = NamespacedKey.crunchy("raw_copper_block_blast_furnace");
+    public static final NamespacedKey FURNACE = NamespacedKey.crunchy("raw_copper_block_furnace");
+
+    private static final ItemStack RESULT = new ItemStack(Material.COPPER_BLOCK);
+    private static final Material MATERIAL = Material.RAW_COPPER_BLOCK;
+
+    public static final class BlastFurnace extends BlastingRecipe {
+
+        public BlastFurnace() {
+            super(BLASTING, RESULT, MATERIAL, CrunchyConfig.smeltRawCopperBlock.experience(), CrunchyConfig.smeltRawCopperBlock.blastCookTime());
+        }
+
+    }
+
+    public static final class Furnace extends FurnaceRecipe {
+
+        public Furnace() {
+            super(FURNACE, RESULT, MATERIAL, CrunchyConfig.smeltRawCopperBlock.experience(), CrunchyConfig.smeltRawCopperBlock.cookTime());
+        }
+
+    }
+
+}
+
diff --git a/src/main/java/dev/mrfishcakes/crunchy/recipe/smeltable/RawGoldBlock.java b/src/main/java/dev/mrfishcakes/crunchy/recipe/smeltable/RawGoldBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..2778f7e9e4f5be4cac4dc12bc242b79600da5a44
--- /dev/null
+++ b/src/main/java/dev/mrfishcakes/crunchy/recipe/smeltable/RawGoldBlock.java
@@ -0,0 +1,35 @@
+package dev.mrfishcakes.crunchy.recipe.smeltable;
+
+import dev.mrfishcakes.crunchy.config.CrunchyConfig;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.inventory.BlastingRecipe;
+import org.bukkit.inventory.FurnaceRecipe;
+import org.bukkit.inventory.ItemStack;
+
+public class RawGoldBlock {
+
+    public static final NamespacedKey BLASTING = NamespacedKey.crunchy("raw_gold_block_blast_furnace");
+    public static final NamespacedKey FURNACE = NamespacedKey.crunchy("raw_gold_block_furnace");
+
+    private static final ItemStack RESULT = new ItemStack(Material.GOLD_BLOCK);
+    private static final Material MATERIAL = Material.RAW_GOLD_BLOCK;
+
+    public static final class BlastFurnace extends BlastingRecipe {
+
+        public BlastFurnace() {
+            super(BLASTING, RESULT, MATERIAL, CrunchyConfig.smeltRawGoldBlock.experience(), CrunchyConfig.smeltRawGoldBlock.blastCookTime());
+        }
+
+    }
+
+    public static final class Furnace extends FurnaceRecipe {
+
+        public Furnace() {
+            super(FURNACE, RESULT, MATERIAL, CrunchyConfig.smeltRawGoldBlock.experience(), CrunchyConfig.smeltRawGoldBlock.cookTime());
+        }
+
+    }
+
+}
+
diff --git a/src/main/java/dev/mrfishcakes/crunchy/recipe/smeltable/RawIronBlock.java b/src/main/java/dev/mrfishcakes/crunchy/recipe/smeltable/RawIronBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..5c291eabb115533011e34979e8b8851cfe80f42a
--- /dev/null
+++ b/src/main/java/dev/mrfishcakes/crunchy/recipe/smeltable/RawIronBlock.java
@@ -0,0 +1,35 @@
+package dev.mrfishcakes.crunchy.recipe.smeltable;
+
+import dev.mrfishcakes.crunchy.config.CrunchyConfig;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.inventory.BlastingRecipe;
+import org.bukkit.inventory.FurnaceRecipe;
+import org.bukkit.inventory.ItemStack;
+
+public class RawIronBlock {
+
+    public static final NamespacedKey BLASTING = NamespacedKey.crunchy("raw_iron_block_blast_furnace");
+    public static final NamespacedKey FURNACE = NamespacedKey.crunchy("raw_iron_block_furnace");
+
+    private static final ItemStack RESULT = new ItemStack(Material.IRON_BLOCK);
+    private static final Material MATERIAL = Material.RAW_IRON_BLOCK;
+
+    public static final class BlastFurnace extends BlastingRecipe {
+
+        public BlastFurnace() {
+            super(BLASTING, RESULT, MATERIAL, CrunchyConfig.smeltRawIronBlock.experience(), CrunchyConfig.smeltRawIronBlock.blastCookTime());
+        }
+
+    }
+
+    public static final class Furnace extends FurnaceRecipe {
+
+        public Furnace() {
+            super(FURNACE, RESULT, MATERIAL, CrunchyConfig.smeltRawIronBlock.experience(), CrunchyConfig.smeltRawIronBlock.cookTime());
+        }
+
+    }
+
+}
+
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/cached_blockpos_iteration/IterateOutwardsCache.java b/src/main/java/me/jellysquid/mods/lithium/common/cached_blockpos_iteration/IterateOutwardsCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..1aaf8527417f3d87e478b760809597d700171edd
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/cached_blockpos_iteration/IterateOutwardsCache.java
@@ -0,0 +1,72 @@
+package me.jellysquid.mods.lithium.common.cached_blockpos_iteration;
+
+import it.unimi.dsi.fastutil.longs.LongArrayList;
+import it.unimi.dsi.fastutil.longs.LongList;
+import java.util.Iterator;
+import wtf.etil.mirai.server.util.FastRandom;
+import java.util.concurrent.ConcurrentHashMap;
+import net.minecraft.core.BlockPos;
+
+/**
+ * @author 2No2Name, original implemenation by SuperCoder7979 and Gegy1000
+ */
+public class IterateOutwardsCache {
+    //POS_ZERO must not be replaced with BlockPos.ORIGIN, otherwise iterateOutwards at BlockPos.ORIGIN will not use the cache
+    public static final BlockPos POS_ZERO = new BlockPos(0,0,0);
+
+
+    private final ConcurrentHashMap<Long, LongArrayList> table;
+    private final int capacity;
+    private final FastRandom random;
+
+    public IterateOutwardsCache(int capacity) {
+        this.capacity = capacity;
+        this.table = new ConcurrentHashMap<>(31);
+        this.random = new FastRandom();
+    }
+
+    private void fillPositionsWithIterateOutwards(LongList entry, int xRange, int yRange, int zRange) {
+        // Add all positions to the cached list
+        for (BlockPos pos : BlockPos.withinManhattan(POS_ZERO, xRange, yRange, zRange)) {
+            entry.add(pos.asLong());
+        }
+    }
+
+    public LongList getOrCompute(int xRange, int yRange, int zRange) {
+        long key = BlockPos.asLong(xRange, yRange, zRange);
+
+        LongArrayList entry = this.table.get(key);
+        if (entry != null) {
+            return entry;
+        }
+
+        // Cache miss: compute and store
+        entry = new LongArrayList(128);
+
+        this.fillPositionsWithIterateOutwards(entry, xRange, yRange, zRange);
+
+        //decrease the array size, as of now it won't be modified anymore anyways
+        entry.trim();
+
+        //this might overwrite an entry as the same entry could have been computed and added during this thread's computation
+        //we do not use computeIfAbsent, as it can delay other threads for too long
+        Object previousEntry = this.table.put(key, entry);
+
+
+        if (previousEntry == null && this.table.size() > this.capacity) {
+            //prevent a memory leak by randomly removing about 1/8th of the elements when the exceed the desired capacity is exceeded
+            final Iterator<Long> iterator = this.table.keySet().iterator();
+            //prevent an unlikely infinite loop caused by another thread filling the table concurrently using counting
+            for (int i = -this.capacity; iterator.hasNext() && i < 5; i++) {
+                Long key2 = iterator.next();
+                //random is not threadsafe, but it doesn't matter here, because we don't need quality random numbers
+                if (this.random.nextInt(8) == 0 && key2 != key) {
+                    iterator.remove();
+                }
+            }
+        }
+
+        return entry;
+    }
+}
+
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/cached_blockpos_iteration/LongList2BlockPosMutableIterable.java b/src/main/java/me/jellysquid/mods/lithium/common/cached_blockpos_iteration/LongList2BlockPosMutableIterable.java
new file mode 100644
index 0000000000000000000000000000000000000000..54662260216b2f88c8da4a00a60f1f1930c3f69b
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/cached_blockpos_iteration/LongList2BlockPosMutableIterable.java
@@ -0,0 +1,47 @@
+package me.jellysquid.mods.lithium.common.cached_blockpos_iteration;
+
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.longs.LongList;
+import java.util.Iterator;
+import net.minecraft.core.BlockPos;
+
+/**
+ * @author 2No2Name
+ */
+public class LongList2BlockPosMutableIterable implements Iterable<BlockPos> {
+
+    private final LongList positions;
+    private final int xOffset, yOffset, zOffset;
+
+    public LongList2BlockPosMutableIterable(BlockPos offset, LongList posList) {
+        this.xOffset = offset.getX();
+        this.yOffset = offset.getY();
+        this.zOffset = offset.getZ();
+        this.positions = posList;
+    }
+
+    @Override
+    public Iterator<BlockPos> iterator() {
+        return new Iterator<BlockPos>() {
+
+            private final LongIterator it = LongList2BlockPosMutableIterable.this.positions.iterator();
+            private final BlockPos.MutableBlockPos pos = new BlockPos.MutableBlockPos();
+
+            @Override
+            public boolean hasNext() {
+                return it.hasNext();
+            }
+
+            @Override
+            public net.minecraft.core.BlockPos next() {
+                long nextPos = this.it.nextLong();
+                return this.pos.set(
+                        LongList2BlockPosMutableIterable.this.xOffset + BlockPos.getX(nextPos),
+                        LongList2BlockPosMutableIterable.this.yOffset + BlockPos.getY(nextPos),
+                        LongList2BlockPosMutableIterable.this.zOffset + BlockPos.getZ(nextPos));
+            }
+        };
+    }
+
+}
+
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/util/Pos.java b/src/main/java/me/jellysquid/mods/lithium/common/util/Pos.java
new file mode 100644
index 0000000000000000000000000000000000000000..99b84f4df0c225166a9d10aacd71b243d119d6c8
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/util/Pos.java
@@ -0,0 +1,93 @@
+package me.jellysquid.mods.lithium.common.util;
+
+import net.minecraft.core.SectionPos;
+import net.minecraft.world.level.LevelHeightAccessor;
+
+public class Pos {
+
+    public static class BlockCoord {
+        public static int getYSize(LevelHeightAccessor view) {
+            return view.getHeight();
+        }
+        public static int getMinY(LevelHeightAccessor view) {
+            return view.getMinBuildHeight();
+        }
+        public static int getMaxYInclusive(LevelHeightAccessor view) {
+            return view.getMaxBuildHeight() - 1;
+        }
+        public static int getMaxYExclusive(LevelHeightAccessor view) {
+            return view.getMaxBuildHeight();
+        }
+
+        public static int getMaxInSectionCoord(int sectionCoord) {
+            return 15 + getMinInSectionCoord(sectionCoord);
+        }
+
+        public static int getMaxYInSectionIndex(LevelHeightAccessor view, int sectionIndex){
+            return getMaxInSectionCoord(SectionYCoord.fromSectionIndex(view, sectionIndex));
+        }
+
+        public static int getMinInSectionCoord(int sectionCoord) {
+            return SectionPos.sectionToBlockCoord(sectionCoord);
+        }
+
+        public static int getMinYInSectionIndex(LevelHeightAccessor view, int sectionIndex) {
+            return getMinInSectionCoord(SectionYCoord.fromSectionIndex(view, sectionIndex));
+        }
+    }
+
+    public static class ChunkCoord {
+        public static int fromBlockCoord(int blockCoord) {
+            return SectionPos.blockToSectionCoord(blockCoord);
+        }
+
+        public static int fromBlockSize(int i) {
+            return i >> 4; //same method as fromBlockCoord, just be clear about coord/size semantic difference
+        }
+    }
+
+    public static class SectionYCoord {
+        public static int getNumYSections(LevelHeightAccessor view) {
+            return view.getSectionsCount();
+        }
+        public static int getMinYSection(LevelHeightAccessor view) {
+            return view.getMinSection();
+        }
+        public static int getMaxYSectionInclusive(LevelHeightAccessor view) {
+            return view.getMaxSection() - 1;
+        }
+        public static int getMaxYSectionExclusive(LevelHeightAccessor view) {
+            return view.getMaxSection();
+        }
+
+        public static int fromSectionIndex(LevelHeightAccessor view, int sectionCoord) {
+            return sectionCoord + SectionYCoord.getMinYSection(view);
+        }
+        public static int fromBlockCoord(int blockCoord) {
+            return SectionPos.blockToSectionCoord(blockCoord);
+        }
+    }
+
+    public static class SectionYIndex {
+        public static int getNumYSections(LevelHeightAccessor view) {
+            return view.getSectionsCount();
+        }
+        public static int getMinYSectionIndex(LevelHeightAccessor view) {
+            return 0;
+        }
+        public static int getMaxYSectionIndexInclusive(LevelHeightAccessor view) {
+            return view.getSectionsCount() - 1;
+        }
+        public static int getMaxYSectionIndexExclusive(LevelHeightAccessor view) {
+            return view.getSectionsCount();
+        }
+
+        public static int fromSectionCoord(LevelHeightAccessor view, int sectionCoord) {
+            return sectionCoord - SectionYCoord.getMinYSection(view);
+        }
+        public static int fromBlockCoord(LevelHeightAccessor view, int blockCoord) {
+            return fromSectionCoord(view, SectionPos.blockToSectionCoord(blockCoord));
+        }
+    }
+}
+
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/util/collections/HashedList.java b/src/main/java/me/jellysquid/mods/lithium/common/util/collections/HashedList.java
new file mode 100644
index 0000000000000000000000000000000000000000..18daf840f14279cfca4e9da45baaa1bfbacf621b
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/util/collections/HashedList.java
@@ -0,0 +1,281 @@
+package me.jellysquid.mods.lithium.common.util.collections;
+
+import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ReferenceArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+
+/**
+ * Wraps a {@link List} with a hash table which provides O(1) lookups for {@link Collection#contains(Object)}. The type
+ * contained by this list must use reference-equality semantics.
+ */
+@SuppressWarnings("SuspiciousMethodCalls")
+public class HashedList<T> implements List<T> {
+    private final ReferenceArrayList<T> list;
+    private final Reference2IntOpenHashMap<T> counter;
+
+    public HashedList(List<T> list) {
+        this.list = new ReferenceArrayList<>();
+        this.list.addAll(list);
+
+        this.counter = new Reference2IntOpenHashMap<>();
+        this.counter.defaultReturnValue(0);
+
+        for (T obj : this.list) {
+            this.counter.addTo(obj, 1);
+        }
+    }
+
+    @Override
+    public int size() {
+        return this.list.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return this.list.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return this.counter.containsKey(o);
+    }
+
+    @Override
+    public Iterator<T> iterator() {
+        return this.listIterator();
+    }
+
+    @Override
+    public Object[] toArray() {
+        return this.list.toArray();
+    }
+
+    @SuppressWarnings("SuspiciousToArrayCall")
+    @Override
+    public <T1> T1[] toArray(T1[] a) {
+        return this.list.toArray(a);
+    }
+
+    @Override
+    public boolean add(T t) {
+        this.trackReferenceAdded(t);
+
+        return this.list.add(t);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        this.trackReferenceRemoved(o);
+
+        return this.list.remove(o);
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        for (Object obj : c) {
+            if (!this.counter.containsKey(obj)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends T> c) {
+        for (T obj : c) {
+            this.trackReferenceAdded(obj);
+        }
+
+        return this.list.addAll(c);
+    }
+
+    @Override
+    public boolean addAll(int index, Collection<? extends T> c) {
+        for (T obj : c) {
+            this.trackReferenceAdded(obj);
+        }
+
+        return this.list.addAll(index, c);
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> c) {
+        for (Object obj : c) {
+            this.trackReferenceRemoved(obj);
+        }
+
+        return this.list.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> c) {
+        return this.list.retainAll(c);
+    }
+
+    @Override
+    public void clear() {
+        this.counter.clear();
+        this.list.clear();
+    }
+
+    @Override
+    public T get(int index) {
+        return this.list.get(index);
+    }
+
+    @Override
+    public T set(int index, T element) {
+        T prev = this.list.set(index, element);
+
+        if (prev != element) {
+            if (prev != null) {
+                this.trackReferenceRemoved(prev);
+            }
+
+            this.trackReferenceAdded(element);
+        }
+
+        return prev;
+    }
+
+    @Override
+    public void add(int index, T element) {
+        this.trackReferenceAdded(element);
+
+        this.list.add(index, element);
+    }
+
+    @Override
+    public T remove(int index) {
+        T prev = this.list.remove(index);
+
+        if (prev != null) {
+            this.trackReferenceRemoved(prev);
+        }
+
+        return prev;
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        return this.list.indexOf(o);
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        return this.list.lastIndexOf(o);
+    }
+
+    @Override
+    public ListIterator<T> listIterator() {
+        return this.listIterator(0);
+    }
+
+    @Override
+    public ListIterator<T> listIterator(int index) {
+        return new ListIterator<T>() {
+            private final ListIterator<T> inner = HashedList.this.list.listIterator(index);
+
+            @Override
+            public boolean hasNext() {
+                return this.inner.hasNext();
+            }
+
+            @Override
+            public T next() {
+                return this.inner.next();
+            }
+
+            @Override
+            public boolean hasPrevious() {
+                return this.inner.hasPrevious();
+            }
+
+            @Override
+            public T previous() {
+                return this.inner.previous();
+            }
+
+            @Override
+            public int nextIndex() {
+                return this.inner.nextIndex();
+            }
+
+            @Override
+            public int previousIndex() {
+                return this.inner.previousIndex();
+            }
+
+            @Override
+            public void remove() {
+                int last = this.previousIndex();
+
+                if (last == -1) {
+                    throw new NoSuchElementException();
+                }
+
+                T prev = HashedList.this.get(last);
+
+                if (prev != null) {
+                    HashedList.this.trackReferenceRemoved(prev);
+                }
+
+                this.inner.remove();
+            }
+
+            @Override
+            public void set(T t) {
+                int last = this.previousIndex();
+
+                if (last == -1) {
+                    throw new NoSuchElementException();
+                }
+
+                T prev = HashedList.this.get(last);
+
+                if (prev != t) {
+                    if (prev != null) {
+                        HashedList.this.trackReferenceRemoved(prev);
+                    }
+
+                    HashedList.this.trackReferenceAdded(t);
+                }
+
+                this.inner.remove();
+            }
+
+            @Override
+            public void add(T t) {
+                HashedList.this.trackReferenceAdded(t);
+
+                this.inner.add(t);
+            }
+        };
+    }
+
+    @Override
+    public List<T> subList(int fromIndex, int toIndex) {
+        return this.list.subList(fromIndex, toIndex);
+    }
+
+    private void trackReferenceAdded(T t) {
+        this.counter.addTo(t, 1);
+    }
+
+    @SuppressWarnings("unchecked")
+    private void trackReferenceRemoved(Object o) {
+        if (this.counter.addTo((T) o, -1) <= 1) {
+            this.counter.removeInt(o);
+        }
+    }
+
+    public static <T> HashedList<T> wrapper(List<T> list) {
+        return new HashedList<>(list);
+    }
+}
+
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/util/math/CompactSineLUT.java b/src/main/java/me/jellysquid/mods/lithium/common/util/math/CompactSineLUT.java
new file mode 100644
index 0000000000000000000000000000000000000000..ac3220413bee5ffc45d4082120865b4f5ab42d16
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/util/math/CompactSineLUT.java
@@ -0,0 +1,90 @@
+package me.jellysquid.mods.lithium.common.util.math;
+
+import net.minecraft.util.Mth;
+
+/**
+ * A replacement for the sine angle lookup table used in {@link Mth}, both reducing the size of LUT and improving
+ * the access patterns for common paired sin/cos operations.
+ *
+ *  sin(-x) = -sin(x)
+ *    ... to eliminate negative angles from the LUT.
+ *
+ *  sin(x) = sin(pi/2 - x)
+ *    ... to eliminate supplementary angles from the LUT.
+ *
+ * Using these identities allows us to reduce the LUT from 64K entries (256 KB) to just 16K entries (64 KB), enabling
+ * it to better fit into the CPU's caches at the expense of some cycles on the fast path. The implementation has been
+ * tightly optimized to avoid branching where possible and to use very quick integer operations.
+ *
+ * Generally speaking, reducing the size of a lookup table is always a good optimization, but since we need to spend
+ * extra CPU cycles trying to maintain parity with vanilla, there is the potential risk that this implementation ends
+ * up being slower than vanilla when the lookup table is able to be kept in cache memory.
+ *
+ * Unlike other "fast math" implementations, the values returned by this class are *bit-for-bit identical* with those
+ * from {@link Mth}. Validation is performed during runtime to ensure that the table is correct.
+ *
+ * @author coderbot16   Author of the original (and very clever) implementation in Rust:
+ *  https://gitlab.com/coderbot16/i73/-/tree/master/i73-trig/src
+ * @author jellysquid3  Additional optimizations, port to Java
+ */
+public class CompactSineLUT {
+    private static final int[] SINE_TABLE_INT = new int[16384 + 1];
+    private static final float SINE_TABLE_MIDPOINT;
+
+    static {
+        final float[] SINE_TABLE = Mth.getSinTable();
+        // Copy the sine table, covering to raw int bits
+        for (int i = 0; i < SINE_TABLE_INT.length; i++) {
+            SINE_TABLE_INT[i] = Float.floatToRawIntBits(SINE_TABLE[i]);
+        }
+
+        SINE_TABLE_MIDPOINT = SINE_TABLE[SINE_TABLE.length / 2];
+
+        // Test that the lookup table is correct during runtime
+        for (int i = 0; i < SINE_TABLE.length; i++) {
+            float expected = SINE_TABLE[i];
+            float value = lookup(i);
+
+            if (expected != value) {
+                throw new IllegalArgumentException(String.format("LUT error at index %d (expected: %s, found: %s)", i, expected, value));
+            }
+        }
+    }
+
+    // [VanillaCopy] MathHelper#sin(float)
+    public static float sin(float f) {
+        return lookup((int) (f * 10430.38) & 0xFFFF);
+    }
+
+    // [VanillaCopy] MathHelper#cos(float)
+    public static float cos(float f) {
+        return lookup((int) (f * 10430.38 + 16384.0) & 0xFFFF);
+    }
+
+    private static float lookup(int index) {
+        // A special case... Is there some way to eliminate this?
+        if (index == 32768) {
+            return SINE_TABLE_MIDPOINT;
+        }
+
+        // Trigonometric identity: sin(-x) = -sin(x)
+        // Given a domain of 0 <= x <= 2*pi, just negate the value if x > pi.
+        // This allows the sin table size to be halved.
+        int neg = (index & 0x8000) << 16;
+
+        // All bits set if (pi/2 <= x), none set otherwise
+        // Extracts the 15th bit from 'half'
+        int mask = (index << 17) >> 31;
+
+        // Trigonometric identity: sin(x) = sin(pi/2 - x)
+        int pos = (0x8001 & mask) + (index ^ mask);
+
+        // Wrap the position in the table. Moving this down to immediately before the array access
+        // seems to help the Hotspot compiler optimize the bit math better.
+        pos &= 0x7fff;
+
+        // Fetch the corresponding value from the LUT and invert the sign bit as needed
+        // This directly manipulate the sign bit on the float bits to simplify logic
+        return Float.intBitsToFloat(SINE_TABLE_INT[pos] ^ neg);
+    }
+}
diff --git a/src/main/java/me/titaniumtown/Constants.java b/src/main/java/me/titaniumtown/Constants.java
new file mode 100644
index 0000000000000000000000000000000000000000..dd37ade3801561a2da0fe859a127c811c54003ea
--- /dev/null
+++ b/src/main/java/me/titaniumtown/Constants.java
@@ -0,0 +1,14 @@
+package me.titaniumtown;
+
+import net.minecraft.core.BlockPos;
+
+public final class Constants {
+    public static final Object[] EMPTY_object_arr = new Object[0];
+    public static final int[] EMPTY_int_arr = new int[0];
+    public static final int[] ZERO_int_arr = new int[]{0};
+    public static final byte[] EMPTY_byte_arr = new byte[0];
+    public static final String[] EMPTY_string_arr = new String[0];
+    public static final long[] EMPTY_long_arr = new long[0];
+    public static final org.bukkit.entity.Entity[] EMPTY_bukkit_entity_arr = new org.bukkit.entity.Entity[0];
+    public static final net.minecraft.world.entity.Entity[] EMPTY_entity_arr = new net.minecraft.world.entity.Entity[0];
+}
diff --git a/src/main/java/me/titaniumtown/JettPackConfig.java b/src/main/java/me/titaniumtown/JettPackConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..07cfbe3e1f9e0d0fbcfd7e16a16e61a0cc0bb219
--- /dev/null
+++ b/src/main/java/me/titaniumtown/JettPackConfig.java
@@ -0,0 +1,118 @@
+package me.titaniumtown;
+
+import com.google.common.base.Throwables;
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+import java.util.regex.Pattern;
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+
+public class JettPackConfig {
+
+    public static File CONFIG_FILE;
+    private static final String HEADER = "This is the main configuration file for JettPack.\n"
+                        + "JettPack does some **experimental** and possibly unstable stuff\n"
+                        + "You've been warned\n";
+    /*========================================================================*/
+    public static YamlConfiguration config;
+    public static int version; // since we're remapping sidestreams' configs we need this public
+    public static boolean verbose; // since we're remapping sidestreams' configs we need this public
+    /*========================================================================*/
+
+    public static void init(File configFile) {
+        CONFIG_FILE = configFile;
+        config = new YamlConfiguration();
+        try {
+            config.load(CONFIG_FILE);
+        } catch (IOException ex) {
+        } catch (InvalidConfigurationException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not load jettpack.yml, please correct your syntax errors", ex);
+            throw Throwables.propagate(ex);
+        }
+        config.options().header(HEADER);
+        config.options().copyDefaults(true);
+        verbose = getBoolean("verbose", false);
+
+        version = getInt("config-version", 1);
+        set("config-version", 1);
+        readConfig(JettPackConfig.class, null);
+    }
+
+    protected static void logError(String s) {
+        Bukkit.getLogger().severe(s);
+    }
+
+    protected static void log(String s) {
+        if (verbose) {
+            Bukkit.getLogger().info(s);
+        }
+    }
+
+    static void readConfig(Class<?> clazz, Object instance) {
+        for (Method method : clazz.getDeclaredMethods()) {
+            if (Modifier.isPrivate(method.getModifiers())) {
+                if (method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE) {
+                    try {
+                        method.setAccessible(true);
+                        method.invoke(instance);
+                    } catch (InvocationTargetException ex) {
+                        throw Throwables.propagate(ex.getCause());
+                    } catch (Exception ex) {
+                        Bukkit.getLogger().log(Level.SEVERE, "Error invoking " + method, ex);
+                    }
+                }
+            }
+        }
+
+        try {
+            config.save(CONFIG_FILE);
+        } catch (IOException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not save " + CONFIG_FILE, ex);
+        }
+    }
+
+    private static final Pattern SPACE = Pattern.compile(" ");
+    private static final Pattern NOT_NUMERIC = Pattern.compile("[^-\\d.]");
+
+
+    private static void set(String path, Object val) {
+        config.set(path, val);
+    }
+
+    private static boolean getBoolean(String path, boolean def) {
+        config.addDefault(path, def);
+        return config.getBoolean(path, config.getBoolean(path));
+    }
+
+    private static double getDouble(String path, double def) {
+        config.addDefault(path, def);
+        return config.getDouble(path, config.getDouble(path));
+    }
+
+    private static float getFloat(String path, float def) {
+        return (float) getDouble(path, (double) def);
+    }
+
+    private static int getInt(String path, int def) {
+        config.addDefault(path, def);
+        return config.getInt(path, config.getInt(path));
+    }
+
+    private static <T> List<T> getList(String path, List<T> def) {
+        config.addDefault(path, def);
+        return (List<T>) config.getList(path, config.getList(path));
+    }
+
+    private static String getString(String path, String def) {
+        config.addDefault(path, def);
+        return config.getString(path, config.getString(path));
+    }
+}
+
diff --git a/src/main/java/me/titaniumtown/util/ServerWorkerWrapper.java b/src/main/java/me/titaniumtown/util/ServerWorkerWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..e9a6624e06ab899f29b5b472eab797bf43fcf6b1
--- /dev/null
+++ b/src/main/java/me/titaniumtown/util/ServerWorkerWrapper.java
@@ -0,0 +1,25 @@
+package me.titaniumtown.util;
+
+import com.google.common.base.Preconditions;
+import net.minecraft.Util;
+
+public final class ServerWorkerWrapper implements Runnable {
+    private final Runnable internalRunnable;
+
+    public ServerWorkerWrapper(Runnable runnable) {
+        this.internalRunnable = Preconditions.checkNotNull(runnable, "internalRunnable");
+    }
+
+    @Override
+    public final void run() {
+        try {
+            this.internalRunnable.run();
+            return;
+        }
+        catch (Throwable throwable) {
+            Util.onThreadException(Thread.currentThread(), throwable);
+            return;
+        }
+    }
+}
+
diff --git a/src/main/java/org/sugarcanemc/sugarcane/cache/NBTCache.java b/src/main/java/org/sugarcanemc/sugarcane/cache/NBTCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..abdebf85e614a3d2dcc8dffa2082e5edd8c9d2c0
--- /dev/null
+++ b/src/main/java/org/sugarcanemc/sugarcane/cache/NBTCache.java
@@ -0,0 +1,33 @@
+package org.sugarcanemc.sugarcane.cache;
+
+import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenCustomHashMap;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.nbt.CompoundTag;
+
+import java.io.File;
+
+public class NBTCache extends Object2ObjectLinkedOpenCustomHashMap<File, CompoundTag> {
+
+    public NBTCache() {
+        super(100, 0.75F, new Strategy<File>() {
+            @Override
+            public int hashCode(File k) {
+                return k.hashCode();
+            }
+
+            @Override
+            public boolean equals(File k, File k1) {
+                return k.equals(k1);
+            }
+        });
+    }
+
+    @Override
+    public CompoundTag put(File k, CompoundTag v) {
+        if (this.size() > MinecraftServer.getServer().getPlayerCount()) {
+            this.removeLast();
+        }
+        return super.putAndMoveToFirst(k, v);
+    }
+}
+
diff --git a/src/main/java/org/sugarcanemc/sugarcane/command/NSPTCommand.java b/src/main/java/org/sugarcanemc/sugarcane/command/NSPTCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..8e60296d18d8b0f2665149c057f11a8942370395
--- /dev/null
+++ b/src/main/java/org/sugarcanemc/sugarcane/command/NSPTCommand.java
@@ -0,0 +1,60 @@
+package org.sugarcanemc.sugarcane.command;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+public class NSPTCommand extends Command {
+
+    public NSPTCommand(String name) {
+        super(name);
+        this.description = "View server tick times in nanoseconds";
+        this.usageMessage = "/nspt";
+        this.setPermission("bukkit.command.nspt");
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        MinecraftServer server = MinecraftServer.getServer();
+
+        List<String> times = new ArrayList<>();
+        times.addAll(eval(server.tickTimes5s.getTimes()));
+        times.addAll(eval(server.tickTimes10s.getTimes()));
+        times.addAll(eval(server.tickTimes60s.getTimes()));
+
+        sender.sendMessage("§6Server tick NS times §e(§7avg§e/§7min§e/§7max§e)§6 from last 5s§7,§6 10s§7,§6 1m§e:");
+        sender.sendMessage(String.format("§6◴ %s§7/%s§7/%s§e, %s§7/%s§7/%s§e, %s§7/%s§7/%s", times.toArray()));
+        return true;
+    }
+
+    private static List<String> eval(long[] times) {
+        long min = Integer.MAX_VALUE;
+        long max = 0L;
+        long total = 0L;
+        for (long value : times) {
+            if (value > 0L && value < min) min = value;
+            if (value > max) max = value;
+            total += value;
+        }
+        double avgD = ((double) total / (double) times.length);
+        return Arrays.asList(getColor(avgD), getColor(min), getColor(max));
+    }
+
+    private static String getColor(double avg) {
+        return ChatColor.COLOR_CHAR + (avg >= 5E+7 ? "c" : avg >= (4E+7) ? "e" : "a") + avg;
+    }
+}
+
diff --git a/src/main/java/org/sugarcanemc/sugarcane/command/StatsCommand.java b/src/main/java/org/sugarcanemc/sugarcane/command/StatsCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..8a904e1ea1f299f7ef67b80afb06459923b2c294
--- /dev/null
+++ b/src/main/java/org/sugarcanemc/sugarcane/command/StatsCommand.java
@@ -0,0 +1,229 @@
+package org.sugarcanemc.sugarcane.command;
+
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import com.sun.management.OperatingSystemMXBean;
+import org.bukkit.World;
+import org.bukkit.boss.BarColor;
+import org.bukkit.boss.BarStyle;
+import org.bukkit.boss.BossBar;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
+import org.bukkit.entity.*;
+import org.bukkit.scheduler.BukkitRunnable;
+import org.sugarcanemc.sugarcane.util.Util;
+
+import java.lang.management.ManagementFactory;
+import java.math.RoundingMode;
+import java.text.DecimalFormat;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class StatsCommand extends Command {
+    private final static int ConsoleBarWidth = 78; //keeping the 80 column standard in mind
+
+    byte cpusamples = 100;
+    DecimalFormat df = new DecimalFormat("00.00");
+    BossBar memoryBar = Bukkit.createBossBar("Memory...", BarColor.BLUE, BarStyle.SEGMENTED_20);
+    BossBar tpsBar = Bukkit.createBossBar("TPS...", BarColor.PINK, BarStyle.SEGMENTED_20);
+    BossBar entityBar = Bukkit.createBossBar("Entities...", BarColor.PINK, BarStyle.SEGMENTED_20);
+    BossBar cpuBar = Bukkit.createBossBar("CPU...", BarColor.GREEN, BarStyle.SEGMENTED_20);
+    OperatingSystemMXBean systemInfo = ManagementFactory.getPlatformMXBean(
+            OperatingSystemMXBean.class);
+    Double current_memory, current_tps;
+    int entities;
+    Long MemUsed, MemMax, MemAlloc;
+    int items = 0, players = 0, minecarts = 0, peaceful = 0, hostile = 0, others = 0;
+    ArrayList<Double> process_cpu = new ArrayList<>(), system_cpu = new ArrayList<>();
+    ConcurrentMap<String, String> entTypes = new ConcurrentHashMap<>();
+    public StatsCommand(String name) {
+        super(name);
+        this.description = "Toggle stats bars";
+        this.usageMessage = "/stats";
+        this.setPermission("sugarcane.command.stats");
+
+        df.setRoundingMode(RoundingMode.CEILING);
+        MemMax = Runtime.getRuntime().maxMemory() / 1024;
+
+        entTypes.put("Unknown", "");
+        entTypes.put("Hostile", "");
+        entTypes.put("Minecart", "");
+        entTypes.put("Peaceful", "");
+        entTypes.put("Items", "");
+        entTypes.put("Other", "");
+
+        new BukkitRunnable() {
+            @Override
+            public void run() {
+                if(Bukkit.isStopping() || MinecraftServer.getServer().hasStopped()) cancel();
+                if (Bukkit.getOnlinePlayers().size() == 0 || entityBar.getPlayers().size() == 0) return;
+                updateCpuBar();
+            }
+        }.runTaskTimerAsynchronously(new MinecraftInternalPlugin(), 0L, 1L);
+
+        new BukkitRunnable() {
+            @Override
+            public void run() {
+                if(Bukkit.isStopping() || MinecraftServer.getServer().hasStopped()) cancel();
+                if (Bukkit.getOnlinePlayers().size() == 0 || entityBar.getPlayers().size() == 0) return;
+                updateTpsMemoryBars();
+            }
+            public void stop() {
+                this.cancel();
+            }
+        }.runTaskTimer(new MinecraftInternalPlugin(), 0L, 1L);
+
+        new BukkitRunnable() {
+            @Override
+            public void run() {
+                if(Bukkit.isStopping() || MinecraftServer.getServer().hasStopped()) cancel();
+                if (Bukkit.getOnlinePlayers().size() == 0 || entityBar.getPlayers().size() == 0) return;
+                updateEntityBar();
+            }
+        }.runTaskTimer(new MinecraftInternalPlugin(), 0L, 1L);
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+        if(sender instanceof ConsoleCommandSender) {
+            for(BossBar bb : new BossBar[]{cpuBar, memoryBar, tpsBar, entityBar}){
+                updateCpuBar();
+                updateTpsMemoryBars();
+                updateEntityBar();
+                sender.sendMessage(bb.getTitle()+"\n"+Util.getTextProgressBar(bb.getProgress()));
+            }
+            return true;
+        }
+        Player p = Bukkit.getPlayer(sender.getName());
+        if (args.length == 0) {
+            if (memoryBar.getPlayers().contains(p)) {
+                cpuBar.removePlayer(p);
+                memoryBar.removePlayer(p);
+                tpsBar.removePlayer(p);
+                entityBar.removePlayer(p);
+            } else {
+                cpuBar.addPlayer(p);
+                memoryBar.addPlayer(p);
+                tpsBar.addPlayer(p);
+                entityBar.addPlayer(p);
+            }
+            return true;
+        }
+        return false;
+    }
+
+    private double calculateAverage(List<Double> list) {
+        List<Double> _list = new ArrayList<>(list);
+        return _list.stream()
+                .mapToDouble(Double::doubleValue)
+                .average()
+                .orElse(0.0);
+    }
+
+    private void updateCpuBar(){
+        double _proc = systemInfo.getProcessCpuLoad();
+        double _sys = systemInfo.getSystemCpuLoad();
+        if(_proc != -1) process_cpu.add(_proc* 100);
+        if(_sys != -1) system_cpu.add(_sys * 100);
+        if (process_cpu.size() > cpusamples) {
+            process_cpu.remove(0);
+        }
+        if (system_cpu.size() > cpusamples) {
+            system_cpu.remove(0);
+        }
+        double _proccpu = calculateAverage(process_cpu);
+        double _syscpu = calculateAverage(system_cpu);
+        cpuBar.setTitle(ChatColor.GREEN + "ProcCPU: " + df.format(_proccpu) + "% | SysCPU: " + df.format(_syscpu) + "%");
+
+        if (_syscpu >= 90) cpuBar.setColor(BarColor.RED);
+        else if (_syscpu >= 75) cpuBar.setColor(BarColor.YELLOW);
+        else cpuBar.setColor(BarColor.GREEN);
+        double cpuAverage = _syscpu / 100;
+        if(cpuAverage < 0) cpuAverage = 0;
+        else if(cpuAverage > 1) cpuAverage = 1;
+        cpuBar.setProgress(cpuAverage);
+    }
+    private void updateTpsMemoryBars(){
+        MemUsed = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
+        MemAlloc = Runtime.getRuntime().totalMemory() / 1048576;
+        current_memory = (MemUsed.doubleValue() / MemMax.doubleValue()) / 1024;
+        current_tps = Arrays.stream(Bukkit.getTPS()).average().orElse(-1);
+        memoryBar.setProgress(current_memory);
+        memoryBar.setTitle(ChatColor.BLUE + "Mem: " + (MemUsed / 1048576) + " MB/" + MemMax / 1024 + " MB (" + MemAlloc + " MB alloc)");
+        tpsBar.setTitle(ChatColor.LIGHT_PURPLE + "TPS: " + df.format(current_tps) + " (" + df.format(Bukkit.getAverageTickTime()) + " MSPT -> "+df.format(1000/Bukkit.getAverageTickTime())+" TPS)");
+        tpsBar.setColor(BarColor.PINK);
+        if (current_tps > 21) tpsBar.setColor(BarColor.YELLOW);
+        if (current_tps > 20) {
+            current_tps = 20D;
+            tpsBar.setColor(BarColor.PURPLE);
+        } else if (current_tps < 18) {
+            tpsBar.setColor(BarColor.YELLOW);
+            if (current_tps < 15)
+                tpsBar.setColor(BarColor.RED);
+        }
+        tpsBar.setProgress(current_tps / 20);
+    }
+    private void updateEntityBar(){
+        items = players = minecarts = peaceful = hostile = others = 0;
+        for (World w : Bukkit.getServer().getWorlds())
+            for (Entity e : w.getEntities()) {
+                if (e instanceof Player) {
+                    players++;
+                } else if (e instanceof Monster || e instanceof Slime
+                        || e instanceof Boss || e instanceof Ghast || e instanceof Shulker
+                        || e instanceof Phantom) {
+                    hostile++;
+                } else if (e instanceof Minecart || e instanceof Boat) {
+                    minecarts++;
+                } else if (e instanceof Animals || e instanceof Golem || e instanceof Ambient
+                        || e instanceof WaterMob) {
+                    peaceful++;
+                } else if (e instanceof Projectile || e instanceof ArmorStand || e instanceof Villager
+                        || e instanceof EvokerFangs || e instanceof AreaEffectCloud
+                        || e instanceof WanderingTrader || e instanceof EnderSignal
+                        || e instanceof EnderCrystal) {
+                    others++;
+                } else if (e instanceof Item || e instanceof ExperienceOrb || e instanceof Hanging) {
+                    items++;
+                } else if (e instanceof FallingBlock || e instanceof Explosive) {
+                    items++;
+                }
+
+            }
+//                for(String key : entTypes.keySet()) {
+//                    if(key.equals("Unknown")) System.out.println(key+": "+entTypes.get(key));
+//                }
+//                Bukkit.getServer().broadcastMessage("New hostile: "+ hostile);
+
+        entities = items + players + minecarts + peaceful + hostile + others;
+        String entTitle = "Entities: " + entities + " (";
+        if (players > 0) entTitle += "Player " + players + " ";
+        if (items > 0) entTitle += "Item " + items + " ";
+        if (minecarts > 0) entTitle += "Cart " + minecarts + " ";
+        if (peaceful > 0) entTitle += "Peace " + peaceful + " ";
+        if (hostile > 0) entTitle += "Hostile " + hostile + (others == 0 ? "" : " ");
+        if (others > 0) entTitle += "+" + others;
+
+        entTitle += ")";
+        entityBar.setTitle(entTitle);
+        if (entities > 5000)
+            entities = 5000;
+        entityBar.setProgress((double) entities / 5000);
+    }
+}
+
diff --git a/src/main/java/org/sugarcanemc/sugarcane/command/SugarcaneCommandsManager.java b/src/main/java/org/sugarcanemc/sugarcane/command/SugarcaneCommandsManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..668a85e73cdc2f0b0b81302674515d49badda3a5
--- /dev/null
+++ b/src/main/java/org/sugarcanemc/sugarcane/command/SugarcaneCommandsManager.java
@@ -0,0 +1,27 @@
+package org.sugarcanemc.sugarcane.command;
+
+import java.util.Map;
+import java.util.HashMap;
+
+import com.mojang.brigadier.CommandDispatcher;
+import net.minecraft.server.commands.SpreadPlayersCommand;
+import org.bukkit.command.Command;
+import net.minecraft.server.MinecraftServer;
+
+public class SugarcaneCommandsManager {
+    private static Map<String, Command> commands;
+
+    public static void registerCommands() {
+        commands = new HashMap<>();
+        commands.put("nspt", new NSPTCommand("nspt"));
+        commands.put("stats", new StatsCommand("stats"));
+        if (commands != null)
+            for (var command : commands.entrySet()) {
+                MinecraftServer.getServer().server.getCommandMap().register(command.getKey(), "Sugarcane", command.getValue());
+            }
+    }
+    public static void registerWithDispatcher(CommandDispatcher dispatcher){
+        SpreadPlayersCommand.register(dispatcher);
+    }
+}
+
diff --git a/src/main/java/org/sugarcanemc/sugarcane/util/Util.java b/src/main/java/org/sugarcanemc/sugarcane/util/Util.java
new file mode 100644
index 0000000000000000000000000000000000000000..61311bf656ecd411afda3724e8c96e4e3f4c988a
--- /dev/null
+++ b/src/main/java/org/sugarcanemc/sugarcane/util/Util.java
@@ -0,0 +1,16 @@
+package org.sugarcanemc.sugarcane.util;
+
+public class Util {
+    private final static int ConsoleBarWidth = 78; //80 column display
+    public static int getIndentation(String s){
+        if(!s.startsWith(" ")) return 0;
+        int i = 0;
+        while((s = s.replaceFirst(" ", "")).startsWith(" ")) i++;
+        return i+1;
+    }
+    public static String getTextProgressBar(double value) {
+        int progress = (int) (value*ConsoleBarWidth);
+        return String.format("[%s%s]", "=".repeat(progress), "_".repeat(ConsoleBarWidth - progress));
+    }
+}
+
diff --git a/src/main/java/wtf/etil/mirai/server/util/FastRandom.java b/src/main/java/wtf/etil/mirai/server/util/FastRandom.java
new file mode 100644
index 0000000000000000000000000000000000000000..5efe9348d892330bd28ad2908ac2da325a9fb5c8
--- /dev/null
+++ b/src/main/java/wtf/etil/mirai/server/util/FastRandom.java
@@ -0,0 +1,65 @@
+package wtf.etil.mirai.server.util;
+
+import org.apache.commons.rng.core.source64.XoRoShiRo128PlusPlus;
+
+import java.util.Random;
+import java.util.SplittableRandom;
+
+public class FastRandom extends Random {
+
+    private XoRoShiRo128PlusPlus random;
+
+    public FastRandom() {
+        super();
+        SplittableRandom randomseed = new SplittableRandom();
+        this.random = new XoRoShiRo128PlusPlus(randomseed.nextLong(), randomseed.nextLong());
+    }
+
+    public FastRandom(long seed) {
+        super(seed);
+        SplittableRandom randomseed = new SplittableRandom(seed);
+        this.random = new XoRoShiRo128PlusPlus(randomseed.nextLong(), randomseed.nextLong());
+    }
+
+    @Override
+    public boolean nextBoolean() {
+        return random.nextBoolean();
+    }
+
+    @Override
+    public int nextInt() {
+        return random.nextInt();
+    }
+
+    @Override
+    public float nextFloat() {
+        return (float) random.nextDouble();
+    }
+
+    @Override
+    public double nextDouble() {
+        return random.nextDouble();
+    }
+
+    @Override
+    public synchronized void setSeed(long seed) {
+        SplittableRandom randomseed = new SplittableRandom(seed);
+        this.random = new XoRoShiRo128PlusPlus(randomseed.nextLong(), randomseed.nextLong());
+    }
+
+    @Override
+    public void nextBytes(byte[] bytes) {
+        random.nextBytes(bytes);
+    }
+
+    @Override
+    public int nextInt(int bound) {
+        return random.nextInt(bound);
+    }
+
+    @Override
+    public long nextLong() {
+        return random.nextLong();
+    }
+}
+
